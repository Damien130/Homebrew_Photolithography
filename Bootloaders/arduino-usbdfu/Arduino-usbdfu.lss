
Arduino-usbdfu.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000006a  00800100  00003c52  00000ce6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c52  00003000  00003000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000001f  0080016a  0080016a  00000d50  2**0
                  ALLOC
  3 .comment      00000024  00000000  00000000  00000d50  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d74  2**2
                  CONTENTS, READONLY, OCTETS
  5 .debug_aranges 00000238  00000000  00000000  00000db8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   00003db3  00000000  00000000  00000ff0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 0000158a  00000000  00000000  00004da3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00004e0a  00000000  00000000  0000632d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  000003a4  00000000  00000000  0000b138  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00001729  00000000  00000000  0000b4dc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loc    000019ba  00000000  00000000  0000cc05  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 000002b0  00000000  00000000  0000e5bf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00003000 <__vectors>:
    3000:	39 c0       	rjmp	.+114    	; 0x3074 <__ctors_end>
    3002:	00 00       	nop
    3004:	52 c0       	rjmp	.+164    	; 0x30aa <__bad_interrupt>
    3006:	00 00       	nop
    3008:	50 c0       	rjmp	.+160    	; 0x30aa <__bad_interrupt>
    300a:	00 00       	nop
    300c:	4e c0       	rjmp	.+156    	; 0x30aa <__bad_interrupt>
    300e:	00 00       	nop
    3010:	4c c0       	rjmp	.+152    	; 0x30aa <__bad_interrupt>
    3012:	00 00       	nop
    3014:	4a c0       	rjmp	.+148    	; 0x30aa <__bad_interrupt>
    3016:	00 00       	nop
    3018:	48 c0       	rjmp	.+144    	; 0x30aa <__bad_interrupt>
    301a:	00 00       	nop
    301c:	46 c0       	rjmp	.+140    	; 0x30aa <__bad_interrupt>
    301e:	00 00       	nop
    3020:	44 c0       	rjmp	.+136    	; 0x30aa <__bad_interrupt>
    3022:	00 00       	nop
    3024:	42 c0       	rjmp	.+132    	; 0x30aa <__bad_interrupt>
    3026:	00 00       	nop
    3028:	40 c0       	rjmp	.+128    	; 0x30aa <__bad_interrupt>
    302a:	00 00       	nop
    302c:	a2 c4       	rjmp	.+2372   	; 0x3972 <__vector_11>
    302e:	00 00       	nop
    3030:	3c c0       	rjmp	.+120    	; 0x30aa <__bad_interrupt>
    3032:	00 00       	nop
    3034:	3a c0       	rjmp	.+116    	; 0x30aa <__bad_interrupt>
    3036:	00 00       	nop
    3038:	38 c0       	rjmp	.+112    	; 0x30aa <__bad_interrupt>
    303a:	00 00       	nop
    303c:	36 c0       	rjmp	.+108    	; 0x30aa <__bad_interrupt>
    303e:	00 00       	nop
    3040:	34 c0       	rjmp	.+104    	; 0x30aa <__bad_interrupt>
    3042:	00 00       	nop
    3044:	32 c0       	rjmp	.+100    	; 0x30aa <__bad_interrupt>
    3046:	00 00       	nop
    3048:	30 c0       	rjmp	.+96     	; 0x30aa <__bad_interrupt>
    304a:	00 00       	nop
    304c:	2e c0       	rjmp	.+92     	; 0x30aa <__bad_interrupt>
    304e:	00 00       	nop
    3050:	2c c0       	rjmp	.+88     	; 0x30aa <__bad_interrupt>
    3052:	00 00       	nop
    3054:	2a c0       	rjmp	.+84     	; 0x30aa <__bad_interrupt>
    3056:	00 00       	nop
    3058:	28 c0       	rjmp	.+80     	; 0x30aa <__bad_interrupt>
    305a:	00 00       	nop
    305c:	26 c0       	rjmp	.+76     	; 0x30aa <__bad_interrupt>
    305e:	00 00       	nop
    3060:	24 c0       	rjmp	.+72     	; 0x30aa <__bad_interrupt>
    3062:	00 00       	nop
    3064:	22 c0       	rjmp	.+68     	; 0x30aa <__bad_interrupt>
    3066:	00 00       	nop
    3068:	20 c0       	rjmp	.+64     	; 0x30aa <__bad_interrupt>
    306a:	00 00       	nop
    306c:	1e c0       	rjmp	.+60     	; 0x30aa <__bad_interrupt>
    306e:	00 00       	nop
    3070:	1c c0       	rjmp	.+56     	; 0x30aa <__bad_interrupt>
    3072:	00 00       	nop

00003074 <__ctors_end>:
    3074:	11 24       	eor	r1, r1
    3076:	1f be       	out	0x3f, r1	; 63
    3078:	cf ef       	ldi	r28, 0xFF	; 255
    307a:	d2 e0       	ldi	r29, 0x02	; 2
    307c:	de bf       	out	0x3e, r29	; 62
    307e:	cd bf       	out	0x3d, r28	; 61

00003080 <__do_copy_data>:
    3080:	11 e0       	ldi	r17, 0x01	; 1

00003082 <.Loc.1>:
    3082:	a0 e0       	ldi	r26, 0x00	; 0

00003084 <.Loc.2>:
    3084:	b1 e0       	ldi	r27, 0x01	; 1

00003086 <.Loc.3>:
    3086:	e2 e5       	ldi	r30, 0x52	; 82

00003088 <.Loc.4>:
    3088:	fc e3       	ldi	r31, 0x3C	; 60

0000308a <.Loc.5>:
    308a:	02 c0       	rjmp	.+4      	; 0x3090 <.L__do_copy_data_start>

0000308c <.L__do_copy_data_loop>:
    308c:	05 90       	lpm	r0, Z+

0000308e <.Loc.7>:
    308e:	0d 92       	st	X+, r0

00003090 <.L__do_copy_data_start>:
    3090:	aa 36       	cpi	r26, 0x6A	; 106

00003092 <.Loc.9>:
    3092:	b1 07       	cpc	r27, r17

00003094 <.Loc.10>:
    3094:	d9 f7       	brne	.-10     	; 0x308c <.L__do_copy_data_loop>

00003096 <__do_clear_bss>:
    3096:	21 e0       	ldi	r18, 0x01	; 1

00003098 <.Loc.1>:
    3098:	aa e6       	ldi	r26, 0x6A	; 106

0000309a <.Loc.2>:
    309a:	b1 e0       	ldi	r27, 0x01	; 1

0000309c <.Loc.3>:
    309c:	01 c0       	rjmp	.+2      	; 0x30a0 <.Loc.5>

0000309e <.Loc.4>:
    309e:	1d 92       	st	X+, r1

000030a0 <.Loc.5>:
    30a0:	a9 38       	cpi	r26, 0x89	; 137

000030a2 <.Loc.6>:
    30a2:	b2 07       	cpc	r27, r18

000030a4 <.Loc.7>:
    30a4:	e1 f7       	brne	.-8      	; 0x309e <.Loc.4>

000030a6 <L0^A>:
    30a6:	2d d1       	rcall	.+602    	; 0x3302 <main>
    30a8:	c8 c5       	rjmp	.+2960   	; 0x3c3a <_exit>

000030aa <__bad_interrupt>:
    30aa:	aa cf       	rjmp	.-172    	; 0x3000 <__vectors>

000030ac <DiscardFillerBytes>:
 *
 *  \param[in] NumberOfBytes  Number of bytes to discard from the host from the control endpoint
 */
static void DiscardFillerBytes(uint8_t NumberOfBytes)
{
	while (NumberOfBytes--)
    30ac:	81 50       	subi	r24, 0x01	; 1
    30ae:	80 f0       	brcs	.+32     	; 0x30d0 <.L1>

000030b0 <.LBB101>:
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
    30b0:	90 91 f2 00 	lds	r25, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

000030b4 <.LBE101>:
	{
		if (!(Endpoint_BytesInEndpoint()))
    30b4:	91 11       	cpse	r25, r1
    30b6:	0d c0       	rjmp	.+26     	; 0x30d2 <.L3>

000030b8 <.LBB103>:
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);	
    30b8:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    30bc:	9b 7f       	andi	r25, 0xFB	; 251
    30be:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000030c2 <.L4>:
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    30c2:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000030c6 <.LBE105>:
		{
			Endpoint_ClearOUT();

			/* Wait until next data packet received */
			while (!(Endpoint_IsOUTReceived()))
    30c6:	92 fd       	sbrc	r25, 2
    30c8:	f1 cf       	rjmp	.-30     	; 0x30ac <DiscardFillerBytes>

000030ca <.Loc.18>:
			{				
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    30ca:	9e b3       	in	r25, 0x1e	; 30

000030cc <.Loc.20>:
    30cc:	91 11       	cpse	r25, r1
    30ce:	f9 cf       	rjmp	.-14     	; 0x30c2 <.L4>

000030d0 <.L1>:
		else
		{
			Endpoint_Discard_Byte();
		}
	}
}
    30d0:	08 95       	ret

000030d2 <.L3>:
			static inline void Endpoint_Discard_Byte(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Discard_Byte(void)
			{
				uint8_t Dummy;
				
				Dummy = UEDATX;
    30d2:	90 91 f1 00 	lds	r25, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

000030d6 <.Loc.27>:
			}
    30d6:	ea cf       	rjmp	.-44     	; 0x30ac <DiscardFillerBytes>

000030d8 <LoadStartEndAddresses>:
{
	union
	{
		uint8_t  Bytes[2];
		uint16_t Word;
	} Address[2] = {{.Bytes = {SentCommand.Data[2], SentCommand.Data[1]}},
    30d8:	e3 e7       	ldi	r30, 0x73	; 115
    30da:	f1 e0       	ldi	r31, 0x01	; 1
    30dc:	82 81       	ldd	r24, Z+2	; 0x02
    30de:	93 81       	ldd	r25, Z+3	; 0x03
    30e0:	58 2f       	mov	r21, r24

000030e2 <.Loc.31>:
    30e2:	49 2f       	mov	r20, r25

000030e4 <.Loc.32>:
    30e4:	84 81       	ldd	r24, Z+4	; 0x04
    30e6:	95 81       	ldd	r25, Z+5	; 0x05
    30e8:	98 27       	eor	r25, r24
    30ea:	89 27       	eor	r24, r25
    30ec:	98 27       	eor	r25, r24

000030ee <.Loc.33>:
	                {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}}};
		
	/* Load in the start and ending read addresses from the sent data packet */
	StartAddr = Address[0].Word;
    30ee:	50 93 6d 01 	sts	0x016D, r21	; 0x80016d <StartAddr+0x1>
    30f2:	40 93 6c 01 	sts	0x016C, r20	; 0x80016c <StartAddr>

000030f6 <.Loc.35>:
	EndAddr   = Address[1].Word;
    30f6:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <EndAddr+0x1>
    30fa:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <EndAddr>

000030fe <.Loc.37>:
}
    30fe:	08 95       	ret

00003100 <ProcessBootloaderCommand>:
{
    3100:	cf 93       	push	r28

00003102 <.LCFI0>:
    3102:	df 93       	push	r29

00003104 <.LCFI1>:
    3104:	00 d0       	rcall	.+0      	; 0x3106 <L0^A>

00003106 <L0^A>:
    3106:	00 d0       	rcall	.+0      	; 0x3108 <L0^A>

00003108 <L0^A>:
    3108:	00 d0       	rcall	.+0      	; 0x310a <L0^A>

0000310a <L0^A>:
    310a:	cd b7       	in	r28, 0x3d	; 61
    310c:	de b7       	in	r29, 0x3e	; 62

0000310e <.LCFI3>:
	switch (SentCommand.Command)
    310e:	80 91 73 01 	lds	r24, 0x0173	; 0x800173 <SentCommand>

00003112 <.Loc.41>:
    3112:	84 30       	cpi	r24, 0x04	; 4
    3114:	09 f4       	brne	.+2      	; 0x3118 <L0^A+0x2>

00003116 <L0^A>:
    3116:	5c c0       	rjmp	.+184    	; 0x31d0 <.L12>
    3118:	68 f4       	brcc	.+26     	; 0x3134 <.L13>
    311a:	81 30       	cpi	r24, 0x01	; 1
    311c:	e9 f0       	breq	.+58     	; 0x3158 <.L14>
    311e:	83 30       	cpi	r24, 0x03	; 3
    3120:	a1 f1       	breq	.+104    	; 0x318a <.L15>

00003122 <.L11>:
}
    3122:	26 96       	adiw	r28, 0x06	; 6
    3124:	0f b6       	in	r0, 0x3f	; 63
    3126:	f8 94       	cli
    3128:	de bf       	out	0x3e, r29	; 62
    312a:	0f be       	out	0x3f, r0	; 63
    312c:	cd bf       	out	0x3d, r28	; 61
    312e:	df 91       	pop	r29
    3130:	cf 91       	pop	r28
    3132:	08 95       	ret

00003134 <.L13>:
	switch (SentCommand.Command)
    3134:	85 30       	cpi	r24, 0x05	; 5
    3136:	09 f4       	brne	.+2      	; 0x313a <L0^A+0x2>

00003138 <L0^A>:
    3138:	9b c0       	rjmp	.+310    	; 0x3270 <.L17>
    313a:	86 30       	cpi	r24, 0x06	; 6
    313c:	91 f7       	brne	.-28     	; 0x3122 <.L11>

0000313e <.Loc.44>:
			if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x03, 0x00))              // Set 64KB flash page command
    313e:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>
    3142:	83 30       	cpi	r24, 0x03	; 3
    3144:	71 f7       	brne	.-36     	; 0x3122 <.L11>

00003146 <.Loc.46>:
    3146:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <SentCommand+0x2>
    314a:	81 11       	cpse	r24, r1
    314c:	ea cf       	rjmp	.-44     	; 0x3122 <.L11>

0000314e <.Loc.47>:
			  Flash64KBPage = SentCommand.Data[2];
    314e:	80 91 76 01 	lds	r24, 0x0176	; 0x800176 <SentCommand+0x3>
    3152:	80 93 6e 01 	sts	0x016E, r24	; 0x80016e <Flash64KBPage>

00003156 <.Loc.49>:
}
    3156:	e5 cf       	rjmp	.-54     	; 0x3122 <.L11>

00003158 <.L14>:
/** Handler for a Memory Program command issued by the host. This routine handles the preparations needed
 *  to write subsequent data from the host into the specified memory.
 */
static void ProcessMemProgCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Write FLASH command
    3158:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>
    315c:	82 30       	cpi	r24, 0x02	; 2
    315e:	08 f7       	brcc	.-62     	; 0x3122 <.L11>

00003160 <.Loc.54>:
	    IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                            // Write EEPROM command
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();
    3160:	bb df       	rcall	.-138    	; 0x30d8 <LoadStartEndAddresses>

00003162 <.LVL3>:
		
		/* If FLASH is being written to, we need to pre-erase the first page to write to */
		if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))
    3162:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>
    3166:	81 11       	cpse	r24, r1
    3168:	0c c0       	rjmp	.+24     	; 0x3182 <.L20>

0000316a <.LBB126>:
		{
			union
			{
				uint16_t Words[2];
				uint32_t Long;
			} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
    316a:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <StartAddr>
    316e:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <StartAddr+0x1>

00003172 <.Loc.59>:
			
			/* Erase the current page's temp buffer */
			boot_page_erase(CurrFlashAddress.Long);
    3172:	23 e0       	ldi	r18, 0x03	; 3
    3174:	fc 01       	movw	r30, r24
    3176:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    317a:	e8 95       	spm

0000317c <.L21>:
			boot_spm_busy_wait();
    317c:	07 b6       	in	r0, 0x37	; 55
    317e:	00 fc       	sbrc	r0, 0
    3180:	fd cf       	rjmp	.-6      	; 0x317c <.L21>

00003182 <.L20>:
		}
		
		/* Set the state so that the next DNLOAD requests reads in the firmware */
		DFU_State = dfuDNLOAD_IDLE;
    3182:	85 e0       	ldi	r24, 0x05	; 5

00003184 <.L39>:
	{
		/* Load in the start and ending read addresses */
		LoadStartEndAddresses();

		/* Set the state so that the next UPLOAD requests read out the firmware */
		DFU_State = dfuUPLOAD_IDLE;
    3184:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <DFU_State>
    3188:	cc cf       	rjmp	.-104    	; 0x3122 <.L11>

0000318a <.L15>:
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00) ||                          // Read FLASH command
    318a:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>

0000318e <.Loc.70>:
    318e:	98 2f       	mov	r25, r24
    3190:	9d 7f       	andi	r25, 0xFD	; 253
    3192:	19 f4       	brne	.+6      	; 0x319a <.L22>

00003194 <.Loc.71>:
		LoadStartEndAddresses();
    3194:	a1 df       	rcall	.-190    	; 0x30d8 <LoadStartEndAddresses>

00003196 <.LVL5>:
		DFU_State = dfuUPLOAD_IDLE;
    3196:	89 e0       	ldi	r24, 0x09	; 9
    3198:	f5 cf       	rjmp	.-22     	; 0x3184 <.L39>

0000319a <.L22>:
	}
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                       // Blank check FLASH command
    319a:	81 30       	cpi	r24, 0x01	; 1
    319c:	09 f0       	breq	.+2      	; 0x31a0 <L0^A+0x2>

0000319e <L0^A>:
    319e:	c1 cf       	rjmp	.-126    	; 0x3122 <.L11>
    31a0:	f0 e0       	ldi	r31, 0x00	; 0
    31a2:	e0 e0       	ldi	r30, 0x00	; 0

000031a4 <.L25>:
		{
			/* Check if the current byte is not blank */
			#if (FLASHEND > 0xFFFF)
			if (pgm_read_byte_far(CurrFlashAddress) != 0xFF)
			#else
			if (pgm_read_byte(CurrFlashAddress) != 0xFF)
    31a4:	84 91       	lpm	r24, Z

000031a6 <.LBE130>:
    31a6:	8f 3f       	cpi	r24, 0xFF	; 255
    31a8:	69 f0       	breq	.+26     	; 0x31c4 <.L24>

000031aa <.Loc.82>:
			#endif
			{
				/* Save the location of the first non-blank byte for response back to the host */
				Flash64KBPage = (CurrFlashAddress >> 16);
    31aa:	10 92 6e 01 	sts	0x016E, r1	; 0x80016e <Flash64KBPage>

000031ae <.Loc.84>:
				StartAddr     = CurrFlashAddress;
    31ae:	f0 93 6d 01 	sts	0x016D, r31	; 0x80016d <StartAddr+0x1>
    31b2:	e0 93 6c 01 	sts	0x016C, r30	; 0x80016c <StartAddr>

000031b6 <.Loc.86>:
			
				/* Set state and status variables to the appropriate error values */
				DFU_State  = dfuERROR;
    31b6:	8a e0       	ldi	r24, 0x0A	; 10

000031b8 <.LVL8>:
    31b8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <DFU_State>

000031bc <.Loc.89>:
				DFU_Status = errCHECK_ERASED;
    31bc:	85 e0       	ldi	r24, 0x05	; 5
    31be:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <DFU_Status>

000031c2 <.Loc.91>:

				break;
    31c2:	af cf       	rjmp	.-162    	; 0x3122 <.L11>

000031c4 <.L24>:
		while (CurrFlashAddress < BOOT_START_ADDR)
    31c4:	31 96       	adiw	r30, 0x01	; 1

000031c6 <.LVL10>:
    31c6:	e1 15       	cp	r30, r1
    31c8:	20 e3       	ldi	r18, 0x30	; 48
    31ca:	f2 07       	cpc	r31, r18
    31cc:	59 f7       	brne	.-42     	; 0x31a4 <.L25>
    31ce:	a9 cf       	rjmp	.-174    	; 0x3122 <.L11>

000031d0 <.L12>:
/** Handler for a Data Write command issued by the host. This routine handles non-programming commands such as
 *  bootloader exit (both via software jumps and hardware watchdog resets) and flash memory erasure.
 */
static void ProcessWriteCommand(void)
{
	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x03))                            // Start application
    31d0:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>

000031d4 <.Loc.100>:
    31d4:	83 30       	cpi	r24, 0x03	; 3
    31d6:	51 f5       	brne	.+84     	; 0x322c <.L26>

000031d8 <.Loc.101>:
	{
		/* Indicate that the bootloader is terminating */
		WaitForExit = true;
    31d8:	81 e0       	ldi	r24, 0x01	; 1
    31da:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <WaitForExit>

000031de <.Loc.103>:

		/* Check if data supplied for the Start Program command - no data executes the program */
		if (SentCommand.DataSize)
    31de:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <SentCommand+0x2>

000031e2 <.Loc.104>:
    31e2:	20 91 79 01 	lds	r18, 0x0179	; 0x800179 <SentCommand+0x6>
    31e6:	30 91 7a 01 	lds	r19, 0x017A	; 0x80017a <SentCommand+0x7>
    31ea:	23 2b       	or	r18, r19
    31ec:	79 f0       	breq	.+30     	; 0x320c <.L27>

000031ee <.Loc.105>:
		{
			if (SentCommand.Data[1] == 0x01)                                   // Start via jump
    31ee:	81 30       	cpi	r24, 0x01	; 1
    31f0:	09 f0       	breq	.+2      	; 0x31f4 <.LBB135>

000031f2 <L0^A>:
    31f2:	97 cf       	rjmp	.-210    	; 0x3122 <.L11>

000031f4 <.LBB135>:
			{
				union
				{
					uint8_t  Bytes[2];
					AppPtr_t FuncPtr;
				} Address = {.Bytes = {SentCommand.Data[4], SentCommand.Data[3]}};
    31f4:	80 91 77 01 	lds	r24, 0x0177	; 0x800177 <SentCommand+0x4>
    31f8:	90 91 78 01 	lds	r25, 0x0178	; 0x800178 <SentCommand+0x5>
    31fc:	98 27       	eor	r25, r24
    31fe:	89 27       	eor	r24, r25
    3200:	98 27       	eor	r25, r24

00003202 <.Loc.109>:

				/* Load in the jump address into the application start address pointer */
				AppStartPtr = Address.FuncPtr;
    3202:	90 93 70 01 	sts	0x0170, r25	; 0x800170 <AppStartPtr+0x1>
    3206:	80 93 6f 01 	sts	0x016F, r24	; 0x80016f <AppStartPtr>
    320a:	8b cf       	rjmp	.-234    	; 0x3122 <.L11>

0000320c <.L27>:
			}
		}
		else
		{
			if (SentCommand.Data[1] == 0x00)                                   // Start via watchdog
    320c:	81 11       	cpse	r24, r1
    320e:	0b c0       	rjmp	.+22     	; 0x3226 <.L28>

00003210 <.LBB136>:
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    3210:	88 e1       	ldi	r24, 0x18	; 24
    3212:	9c e0       	ldi	r25, 0x0C	; 12
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	f8 94       	cli
    3218:	a8 95       	wdr
    321a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    321e:	0f be       	out	0x3f, r0	; 63
    3220:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__DATA_REGION_ORIGIN__>

00003224 <.Loc.117>:
				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
						_BV(WDE) | (value & 0x07)) )
				: "r0"
		);
	}
}
    3224:	7e cf       	rjmp	.-260    	; 0x3122 <.L11>

00003226 <.L28>:
				wdt_enable(WDTO_250MS);
			}
			else                                                               // Start via jump
			{
				/* Set the flag to terminate the bootloader at next opportunity */
				RunBootloader = false;
    3226:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <RunBootloader>
    322a:	7b cf       	rjmp	.-266    	; 0x3122 <.L11>

0000322c <.L26>:
			}
		}
	}
	else if (IS_TWOBYTE_COMMAND(SentCommand.Data, 0x00, 0xFF))                 // Erase flash
    322c:	81 11       	cpse	r24, r1
    322e:	79 cf       	rjmp	.-270    	; 0x3122 <.L11>

00003230 <.Loc.123>:
    3230:	80 91 75 01 	lds	r24, 0x0175	; 0x800175 <SentCommand+0x2>
    3234:	8f 3f       	cpi	r24, 0xFF	; 255
    3236:	09 f0       	breq	.+2      	; 0x323a <L0^A+0x2>

00003238 <L0^A>:
    3238:	74 cf       	rjmp	.-280    	; 0x3122 <.L11>
    323a:	f0 e0       	ldi	r31, 0x00	; 0
    323c:	e0 e0       	ldi	r30, 0x00	; 0

0000323e <.LBB138>:
		uint32_t CurrFlashAddress = 0;

		/* Clear the application section of flash */
		while (CurrFlashAddress < BOOT_START_ADDR)
		{
			boot_page_erase(CurrFlashAddress);
    323e:	83 e0       	ldi	r24, 0x03	; 3

00003240 <.Loc.125>:
			boot_spm_busy_wait();
			boot_page_write(CurrFlashAddress);
    3240:	95 e0       	ldi	r25, 0x05	; 5

00003242 <.L31>:
			boot_page_erase(CurrFlashAddress);
    3242:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    3246:	e8 95       	spm

00003248 <.L29>:
			boot_spm_busy_wait();
    3248:	07 b6       	in	r0, 0x37	; 55
    324a:	00 fc       	sbrc	r0, 0
    324c:	fd cf       	rjmp	.-6      	; 0x3248 <.L29>

0000324e <.Loc.130>:
			boot_page_write(CurrFlashAddress);
    324e:	90 93 57 00 	sts	0x0057, r25	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    3252:	e8 95       	spm

00003254 <.L30>:
			boot_spm_busy_wait();
    3254:	07 b6       	in	r0, 0x37	; 55
    3256:	00 fc       	sbrc	r0, 0
    3258:	fd cf       	rjmp	.-6      	; 0x3254 <.L30>

0000325a <.Loc.134>:
		while (CurrFlashAddress < BOOT_START_ADDR)
    325a:	e0 58       	subi	r30, 0x80	; 128
    325c:	ff 4f       	sbci	r31, 0xFF	; 255
    325e:	e1 15       	cp	r30, r1
    3260:	20 e3       	ldi	r18, 0x30	; 48
    3262:	f2 07       	cpc	r31, r18
    3264:	71 f7       	brne	.-36     	; 0x3242 <.L31>

00003266 <.Loc.136>:

			CurrFlashAddress += SPM_PAGESIZE;
		}

		/* Re-enable the RWW section of flash as writing to the flash locks it out */
		boot_rww_enable();
    3266:	81 e1       	ldi	r24, 0x11	; 17
    3268:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    326c:	e8 95       	spm
    326e:	59 cf       	rjmp	.-334    	; 0x3122 <.L11>

00003270 <.L17>:
/** Handler for a Data Read command issued by the host. This routine handles bootloader information retrieval
 *  commands such as device signature and bootloader version retrieval.
 */
static void ProcessReadCommand(void)
{
	const uint8_t BootloaderInfo[3] = {BOOTLOADER_VERSION, BOOTLOADER_ID_BYTE1, BOOTLOADER_ID_BYTE2};
    3270:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <DeviceDescriptor+0x12>
    3274:	90 91 62 01 	lds	r25, 0x0162	; 0x800162 <DeviceDescriptor+0x13>
    3278:	a0 91 63 01 	lds	r26, 0x0163	; 0x800163 <DeviceDescriptor+0x14>
    327c:	8c 83       	std	Y+4, r24	; 0x04
    327e:	9d 83       	std	Y+5, r25	; 0x05
    3280:	ae 83       	std	Y+6, r26	; 0x06

00003282 <.Loc.141>:
	const uint8_t SignatureInfo[3]  = {AVR_SIGNATURE_1,    AVR_SIGNATURE_2,     AVR_SIGNATURE_3};
    3282:	80 91 65 01 	lds	r24, 0x0165	; 0x800165 <DeviceDescriptor+0x16>
    3286:	90 91 66 01 	lds	r25, 0x0166	; 0x800166 <DeviceDescriptor+0x17>
    328a:	a0 91 67 01 	lds	r26, 0x0167	; 0x800167 <DeviceDescriptor+0x18>
    328e:	89 83       	std	Y+1, r24	; 0x01
    3290:	9a 83       	std	Y+2, r25	; 0x02
    3292:	ab 83       	std	Y+3, r26	; 0x03

00003294 <.Loc.143>:

	uint8_t DataIndexToRead = SentCommand.Data[1];
    3294:	e0 91 75 01 	lds	r30, 0x0175	; 0x800175 <SentCommand+0x2>

00003298 <.LVL14>:

	if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))                         // Read bootloader info
    3298:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>

0000329c <.Loc.147>:
    329c:	81 11       	cpse	r24, r1
    329e:	07 c0       	rjmp	.+14     	; 0x32ae <.L32>

000032a0 <.Loc.148>:
	  ResponseByte = BootloaderInfo[DataIndexToRead];
    32a0:	ec 0f       	add	r30, r28
    32a2:	fd 2f       	mov	r31, r29
    32a4:	f1 1d       	adc	r31, r1

000032a6 <.LVL15>:
    32a6:	84 81       	ldd	r24, Z+4	; 0x04

000032a8 <.L40>:
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
	  ResponseByte = SignatureInfo[DataIndexToRead - 0x30];
    32a8:	80 93 7e 01 	sts	0x017E, r24	; 0x80017e <ResponseByte>

000032ac <.Loc.152>:
}
    32ac:	3a cf       	rjmp	.-396    	; 0x3122 <.L11>

000032ae <.L32>:
	else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))                    // Read signature byte
    32ae:	81 30       	cpi	r24, 0x01	; 1
    32b0:	09 f0       	breq	.+2      	; 0x32b4 <.Loc.155>

000032b2 <L0^A>:
    32b2:	37 cf       	rjmp	.-402    	; 0x3122 <.L11>

000032b4 <.Loc.155>:
	  ResponseByte = SignatureInfo[DataIndexToRead - 0x30];
    32b4:	81 ed       	ldi	r24, 0xD1	; 209
    32b6:	9f ef       	ldi	r25, 0xFF	; 255
    32b8:	8c 0f       	add	r24, r28
    32ba:	9d 1f       	adc	r25, r29
    32bc:	8e 0f       	add	r24, r30
    32be:	91 1d       	adc	r25, r1
    32c0:	fc 01       	movw	r30, r24

000032c2 <.LVL17>:
    32c2:	80 81       	ld	r24, Z
    32c4:	f1 cf       	rjmp	.-30     	; 0x32a8 <.L40>

000032c6 <SetupHardware>:
	MCUSR &= ~(1 << WDRF);
    32c6:	84 b7       	in	r24, 0x34	; 52
    32c8:	87 7f       	andi	r24, 0xF7	; 247
    32ca:	84 bf       	out	0x34, r24	; 52

000032cc <.LBB145>:
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    32cc:	0f b6       	in	r0, 0x3f	; 63
    32ce:	f8 94       	cli
    32d0:	a8 95       	wdr
    32d2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    32d6:	88 61       	ori	r24, 0x18	; 24
    32d8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    32dc:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
    32e0:	0f be       	out	0x3f, r0	; 63

000032e2 <.LBE146>:
	MCUCR = (1 << IVCE);
    32e2:	81 e0       	ldi	r24, 0x01	; 1
    32e4:	85 bf       	out	0x35, r24	; 53

000032e6 <.Loc.168>:
	MCUCR = (1 << IVSEL);
    32e6:	82 e0       	ldi	r24, 0x02	; 2
    32e8:	85 bf       	out	0x35, r24	; 53

000032ea <.LBB148>:

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |= LEDS_ALL_LEDS;
    32ea:	8a b1       	in	r24, 0x0a	; 10
    32ec:	80 63       	ori	r24, 0x30	; 48
    32ee:	8a b9       	out	0x0a, r24	; 10

000032f0 <.Loc.174>:
				PORTD |= LEDS_ALL_LEDS;
    32f0:	8b b1       	in	r24, 0x0b	; 11
    32f2:	80 63       	ori	r24, 0x30	; 48
    32f4:	8b b9       	out	0x0b, r24	; 11

000032f6 <.LBE148>:
	USB_Init();
    32f6:	1c c3       	rjmp	.+1592   	; 0x3930 <USB_Init>

000032f8 <ResetHardware>:
	USB_ShutDown();
    32f8:	20 d3       	rcall	.+1600   	; 0x393a <USB_ShutDown>

000032fa <.LVL19>:
	MCUCR = (1 << IVCE);
    32fa:	81 e0       	ldi	r24, 0x01	; 1
    32fc:	85 bf       	out	0x35, r24	; 53

000032fe <.Loc.181>:
	MCUCR = 0;
    32fe:	15 be       	out	0x35, r1	; 53

00003300 <.Loc.183>:
}
    3300:	08 95       	ret

00003302 <main>:
	SetupHardware();
    3302:	e1 df       	rcall	.-62     	; 0x32c6 <SetupHardware>

00003304 <.LVL20>:
	sei();
    3304:	78 94       	sei

00003306 <.L44>:
	while (RunBootloader || WaitForExit)
    3306:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <RunBootloader>
    330a:	81 11       	cpse	r24, r1
    330c:	0a c0       	rjmp	.+20     	; 0x3322 <.L45>

0000330e <.Loc.189>:
    330e:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <WaitForExit>
    3312:	81 11       	cpse	r24, r1
    3314:	06 c0       	rjmp	.+12     	; 0x3322 <.L45>

00003316 <.Loc.190>:
	ResetHardware();
    3316:	f0 df       	rcall	.-32     	; 0x32f8 <ResetHardware>

00003318 <.LVL21>:
	AppStartPtr();
    3318:	e0 91 6f 01 	lds	r30, 0x016F	; 0x80016f <AppStartPtr>
    331c:	f0 91 70 01 	lds	r31, 0x0170	; 0x800170 <AppStartPtr+0x1>
    3320:	09 95       	icall

00003322 <.L45>:
	  USB_USBTask();
    3322:	67 d4       	rcall	.+2254   	; 0x3bf2 <USB_USBTask>

00003324 <.LVL23>:
    3324:	f0 cf       	rjmp	.-32     	; 0x3306 <.L44>

00003326 <EVENT_USB_Device_UnhandledControlRequest>:
{
    3326:	7f 92       	push	r7

00003328 <.LCFI4>:
    3328:	8f 92       	push	r8

0000332a <.LCFI5>:
    332a:	9f 92       	push	r9

0000332c <.LCFI6>:
    332c:	af 92       	push	r10

0000332e <.LCFI7>:
    332e:	bf 92       	push	r11

00003330 <.LCFI8>:
    3330:	cf 92       	push	r12

00003332 <.LCFI9>:
    3332:	df 92       	push	r13

00003334 <.LCFI10>:
    3334:	ef 92       	push	r14

00003336 <.LCFI11>:
    3336:	ff 92       	push	r15

00003338 <.LCFI12>:
    3338:	0f 93       	push	r16

0000333a <.LCFI13>:
    333a:	1f 93       	push	r17

0000333c <.LCFI14>:
    333c:	cf 93       	push	r28

0000333e <.LCFI15>:
    333e:	df 93       	push	r29

00003340 <.LCFI16>:
	SentCommand.DataSize = USB_ControlRequest.wLength;
    3340:	80 91 87 01 	lds	r24, 0x0187	; 0x800187 <USB_ControlRequest+0x6>
    3344:	90 91 88 01 	lds	r25, 0x0188	; 0x800188 <USB_ControlRequest+0x7>
    3348:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <SentCommand+0x7>
    334c:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <SentCommand+0x6>

00003350 <.Loc.196>:
	if (PulseMSRemaining.TxLEDPulse && !(--PulseMSRemaining.TxLEDPulse))
    3350:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <PulseMSRemaining>

00003354 <.Loc.198>:
    3354:	88 23       	and	r24, r24
    3356:	41 f0       	breq	.+16     	; 0x3368 <.L48>

00003358 <.Loc.199>:
    3358:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <PulseMSRemaining>

0000335c <.Loc.200>:
    335c:	81 50       	subi	r24, 0x01	; 1

0000335e <.Loc.201>:
    335e:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <PulseMSRemaining>
    3362:	81 11       	cpse	r24, r1
    3364:	01 c0       	rjmp	.+2      	; 0x3368 <.L48>

00003366 <.LBB250>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
			{
				PORTD |= LEDMask;
    3366:	5d 9a       	sbi	0x0b, 5	; 11

00003368 <.L48>:
	if (PulseMSRemaining.RxLEDPulse && !(--PulseMSRemaining.RxLEDPulse))
    3368:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <PulseMSRemaining+0x1>

0000336c <.Loc.209>:
    336c:	88 23       	and	r24, r24
    336e:	41 f0       	breq	.+16     	; 0x3380 <.L51>

00003370 <.Loc.210>:
    3370:	80 91 7c 01 	lds	r24, 0x017C	; 0x80017c <PulseMSRemaining+0x1>

00003374 <.Loc.211>:
    3374:	81 50       	subi	r24, 0x01	; 1

00003376 <.Loc.212>:
    3376:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <PulseMSRemaining+0x1>
    337a:	81 11       	cpse	r24, r1
    337c:	01 c0       	rjmp	.+2      	; 0x3380 <.L51>

0000337e <.LBB252>:
    337e:	5c 9a       	sbi	0x0b, 4	; 11

00003380 <.L51>:
	switch (USB_ControlRequest.bRequest)
    3380:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <USB_ControlRequest+0x1>

00003384 <.Loc.220>:
    3384:	84 30       	cpi	r24, 0x04	; 4
    3386:	09 f4       	brne	.+2      	; 0x338a <L0^A+0x2>

00003388 <L0^A>:
    3388:	cd c1       	rjmp	.+922    	; 0x3724 <.L53>
    338a:	b0 f4       	brcc	.+44     	; 0x33b8 <.L54>
    338c:	82 30       	cpi	r24, 0x02	; 2
    338e:	09 f4       	brne	.+2      	; 0x3392 <L0^A+0x2>

00003390 <L0^A>:
    3390:	22 c1       	rjmp	.+580    	; 0x35d6 <.L55>
    3392:	83 30       	cpi	r24, 0x03	; 3
    3394:	09 f4       	brne	.+2      	; 0x3398 <L0^A+0x2>

00003396 <L0^A>:
    3396:	b0 c1       	rjmp	.+864    	; 0x36f8 <.L56>
    3398:	81 30       	cpi	r24, 0x01	; 1
    339a:	f1 f0       	breq	.+60     	; 0x33d8 <.L57>

0000339c <.L46>:
}
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	1f 91       	pop	r17
    33a2:	0f 91       	pop	r16
    33a4:	ff 90       	pop	r15
    33a6:	ef 90       	pop	r14
    33a8:	df 90       	pop	r13
    33aa:	cf 90       	pop	r12
    33ac:	bf 90       	pop	r11
    33ae:	af 90       	pop	r10
    33b0:	9f 90       	pop	r9
    33b2:	8f 90       	pop	r8
    33b4:	7f 90       	pop	r7
    33b6:	08 95       	ret

000033b8 <.L54>:
	switch (USB_ControlRequest.bRequest)
    33b8:	85 30       	cpi	r24, 0x05	; 5
    33ba:	09 f4       	brne	.+2      	; 0x33be <L0^A+0x2>

000033bc <L0^A>:
    33bc:	bb c1       	rjmp	.+886    	; 0x3734 <.L59>
    33be:	86 30       	cpi	r24, 0x06	; 6
    33c0:	69 f7       	brne	.-38     	; 0x339c <.L46>

000033c2 <.LBB254>:
				UEINTX &= ~(1 << RXSTPI);
    33c2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    33c6:	87 7f       	andi	r24, 0xF7	; 247
    33c8:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000033cc <.LBB256>:
    33cc:	5d 9a       	sbi	0x0b, 5	; 11

000033ce <.LBB258>:
    33ce:	5c 9a       	sbi	0x0b, 4	; 11

000033d0 <.LBE258>:
			DFU_State = dfuIDLE;
    33d0:	82 e0       	ldi	r24, 0x02	; 2
    33d2:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <DFU_State>
    33d6:	2b c0       	rjmp	.+86     	; 0x342e <.L141>

000033d8 <.L57>:
				PORTD &= ~LEDMask;
    33d8:	5c 98       	cbi	0x0b, 4	; 11

000033da <.LBE260>:
			PulseMSRemaining.RxLEDPulse = TX_RX_LED_PULSE_MS;		
    33da:	83 e0       	ldi	r24, 0x03	; 3
    33dc:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <PulseMSRemaining+0x1>

000033e0 <.LBB262>:
    33e0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    33e4:	87 7f       	andi	r24, 0xF7	; 247
    33e6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000033ea <.LBE262>:
			if (WaitForExit)
    33ea:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <WaitForExit>
    33ee:	88 23       	and	r24, r24
    33f0:	29 f0       	breq	.+10     	; 0x33fc <.L61>

000033f2 <.Loc.252>:
				ProcessBootloaderCommand();
    33f2:	86 de       	rcall	.-756    	; 0x3100 <ProcessBootloaderCommand>

000033f4 <.LBB264>:
				PORTD |= LEDMask;
    33f4:	5d 9a       	sbi	0x0b, 5	; 11

000033f6 <.LBB266>:
    33f6:	5c 9a       	sbi	0x0b, 4	; 11

000033f8 <.LBE266>:
				WaitForExit = false;
    33f8:	10 92 72 01 	sts	0x0172, r1	; 0x800172 <WaitForExit>

000033fc <.L61>:
			if (SentCommand.DataSize)
    33fc:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <SentCommand+0x6>
    3400:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <SentCommand+0x7>

00003404 <.Loc.267>:
    3404:	00 97       	sbiw	r24, 0x00	; 0
    3406:	29 f5       	brne	.+74     	; 0x3452 <.L62>

00003408 <.L63>:
			if (DFU_State == dfuDNLOAD_IDLE)
    3408:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <DFU_State>
    340c:	85 30       	cpi	r24, 0x05	; 5
    340e:	51 f4       	brne	.+20     	; 0x3424 <.L68>

00003410 <.Loc.270>:
				if (!(SentCommand.DataSize))
    3410:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <SentCommand+0x6>
    3414:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <SentCommand+0x7>
    3418:	89 2b       	or	r24, r25
    341a:	09 f0       	breq	.+2      	; 0x341e <.Loc.272>

0000341c <L0^A>:
    341c:	3f c0       	rjmp	.+126    	; 0x349c <.L69>

0000341e <.Loc.272>:
					DFU_State = dfuIDLE;
    341e:	82 e0       	ldi	r24, 0x02	; 2
    3420:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <DFU_State>

00003424 <.L68>:
					UEINTX &= ~(1 << RXOUTI);	
    3424:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3428:	8b 7f       	andi	r24, 0xFB	; 251

0000342a <.L142>:
					UEINTX &= ~(1 << TXINI);
    342a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000342e <.L141>:
}
    342e:	df 91       	pop	r29
    3430:	cf 91       	pop	r28
    3432:	1f 91       	pop	r17
    3434:	0f 91       	pop	r16
    3436:	ff 90       	pop	r15
    3438:	ef 90       	pop	r14
    343a:	df 90       	pop	r13
    343c:	cf 90       	pop	r12
    343e:	bf 90       	pop	r11
    3440:	af 90       	pop	r10
    3442:	9f 90       	pop	r9
    3444:	8f 90       	pop	r8
    3446:	7f 90       	pop	r7

00003448 <.Loc.282>:
			Endpoint_ClearStatusStage();
    3448:	c7 c1       	rjmp	.+910    	; 0x37d8 <Endpoint_ClearStatusStage>

0000344a <.L64>:
					if (USB_DeviceState == DEVICE_STATE_Unattached)
    344a:	2e b3       	in	r18, 0x1e	; 30

0000344c <.Loc.285>:
    344c:	22 23       	and	r18, r18
    344e:	09 f4       	brne	.+2      	; 0x3452 <.L62>

00003450 <L0^A>:
    3450:	a5 cf       	rjmp	.-182    	; 0x339c <.L46>

00003452 <.L62>:
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    3452:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003456 <.LBE273>:
				while (!(Endpoint_IsOUTReceived()))
    3456:	22 ff       	sbrs	r18, 2
    3458:	f8 cf       	rjmp	.-16     	; 0x344a <.L64>

0000345a <.LBB275>:
				return UEDATX;
    345a:	20 91 f1 00 	lds	r18, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000345e <.LBE275>:
				SentCommand.Command = Endpoint_Read_Byte();
    345e:	20 93 73 01 	sts	0x0173, r18	; 0x800173 <SentCommand>

00003462 <.Loc.296>:
				SentCommand.DataSize--;
    3462:	01 97       	sbiw	r24, 0x01	; 1
    3464:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <SentCommand+0x7>
    3468:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <SentCommand+0x6>

0000346c <.LBB277>:
				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
    346c:	e4 e7       	ldi	r30, 0x74	; 116
    346e:	f1 e0       	ldi	r31, 0x01	; 1

00003470 <.L65>:
					return UEBCLX;
    3470:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

00003474 <.LBE278>:
    3474:	88 23       	and	r24, r24
    3476:	81 f0       	breq	.+32     	; 0x3498 <.L67>

00003478 <.LBB280>:
				return UEDATX;
    3478:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000347c <.LBE280>:
					SentCommand.Data[DataByte] = Endpoint_Read_Byte();
    347c:	81 93       	st	Z+, r24

0000347e <.LVL41>:
					SentCommand.DataSize--;
    347e:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <SentCommand+0x6>
    3482:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <SentCommand+0x7>
    3486:	01 97       	sbiw	r24, 0x01	; 1
    3488:	90 93 7a 01 	sts	0x017A, r25	; 0x80017a <SentCommand+0x7>
    348c:	80 93 79 01 	sts	0x0179, r24	; 0x800179 <SentCommand+0x6>

00003490 <.LVL42>:
				for (uint8_t DataByte = 0; (DataByte < sizeof(SentCommand.Data)) &&
    3490:	21 e0       	ldi	r18, 0x01	; 1
    3492:	e9 37       	cpi	r30, 0x79	; 121
    3494:	f2 07       	cpc	r31, r18
    3496:	61 f7       	brne	.-40     	; 0x3470 <.L65>

00003498 <.L67>:
				ProcessBootloaderCommand();
    3498:	33 de       	rcall	.-922    	; 0x3100 <ProcessBootloaderCommand>

0000349a <.LVL44>:
    349a:	b6 cf       	rjmp	.-148    	; 0x3408 <.L63>

0000349c <.L69>:
					DiscardFillerBytes(DFU_FILLER_BYTES_SIZE);
    349c:	8a e1       	ldi	r24, 0x1A	; 26
    349e:	06 de       	rcall	.-1012   	; 0x30ac <DiscardFillerBytes>

000034a0 <.LVL45>:
					DiscardFillerBytes(StartAddr % FIXED_CONTROL_ENDPOINT_SIZE);
    34a0:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <StartAddr>
    34a4:	8f 71       	andi	r24, 0x1F	; 31
    34a6:	02 de       	rcall	.-1020   	; 0x30ac <DiscardFillerBytes>

000034a8 <.LVL46>:
					uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
    34a8:	40 91 6c 01 	lds	r20, 0x016C	; 0x80016c <StartAddr>
    34ac:	50 91 6d 01 	lds	r21, 0x016D	; 0x80016d <StartAddr+0x1>

000034b0 <.Loc.321>:
    34b0:	c0 91 6a 01 	lds	r28, 0x016A	; 0x80016a <EndAddr>
    34b4:	d0 91 6b 01 	lds	r29, 0x016B	; 0x80016b <EndAddr+0x1>
    34b8:	21 96       	adiw	r28, 0x01	; 1
    34ba:	c4 1b       	sub	r28, r20
    34bc:	d5 0b       	sbc	r29, r21

000034be <.LVL47>:
					if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))        // Write flash
    34be:	20 91 74 01 	lds	r18, 0x0174	; 0x800174 <SentCommand+0x1>

000034c2 <.Loc.324>:
    34c2:	21 11       	cpse	r18, r1
    34c4:	78 c0       	rjmp	.+240    	; 0x35b6 <.L70>

000034c6 <.LBB283>:
						uint16_t WordsRemaining = (BytesRemaining >> 1);
    34c6:	d6 95       	lsr	r29
    34c8:	c7 95       	ror	r28

000034ca <.LVL48>:
						} CurrFlashAddress                 = {.Words = {StartAddr, Flash64KBPage}};
    34ca:	ca 01       	movw	r24, r20

000034cc <.Loc.329>:
    34cc:	30 91 6e 01 	lds	r19, 0x016E	; 0x80016e <Flash64KBPage>
    34d0:	a3 2f       	mov	r26, r19

000034d2 <.Loc.330>:
    34d2:	b0 e0       	ldi	r27, 0x00	; 0

000034d4 <.Loc.331>:
						uint32_t CurrFlashPageStartAddress = CurrFlashAddress.Long;
    34d4:	4a 01       	movw	r8, r20

000034d6 <.LVL49>:
							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_Word_LE());
    34d6:	11 e0       	ldi	r17, 0x01	; 1

000034d8 <.Loc.336>:
								boot_page_write(CurrFlashPageStartAddress);
    34d8:	05 e0       	ldi	r16, 0x05	; 5

000034da <.Loc.337>:
									boot_page_erase(CurrFlashAddress.Long);
    34da:	33 e0       	ldi	r19, 0x03	; 3
    34dc:	73 2e       	mov	r7, r19

000034de <.L71>:
						while (WordsRemaining--)
    34de:	ae 01       	movw	r20, r28
    34e0:	41 50       	subi	r20, 0x01	; 1
    34e2:	51 09       	sbc	r21, r1

000034e4 <.LVL51>:
    34e4:	cd 2b       	or	r28, r29
    34e6:	79 f4       	brne	.+30     	; 0x3506 <.L81>

000034e8 <.Loc.341>:
						StartAddr = EndAddr;
    34e8:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <EndAddr>
    34ec:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <EndAddr+0x1>

000034f0 <.Loc.343>:
    34f0:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <StartAddr+0x1>
    34f4:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <StartAddr>

000034f8 <.Loc.344>:
						boot_rww_enable();
    34f8:	81 e1       	ldi	r24, 0x11	; 17
    34fa:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    34fe:	e8 95       	spm

00003500 <.L82>:
					DiscardFillerBytes(DFU_FILE_SUFFIX_SIZE);
    3500:	80 e1       	ldi	r24, 0x10	; 16
    3502:	d4 dd       	rcall	.-1112   	; 0x30ac <DiscardFillerBytes>

00003504 <.LVL53>:
    3504:	8f cf       	rjmp	.-226    	; 0x3424 <.L68>

00003506 <.L81>:
					return UEBCLX;
    3506:	30 91 f2 00 	lds	r19, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

0000350a <.LBE284>:
							if (!(Endpoint_BytesInEndpoint()))
    350a:	33 23       	and	r19, r19
    350c:	69 f1       	breq	.+90     	; 0x3568 <.L72>

0000350e <.L77>:
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;
				
				Data.Bytes[0] = UEDATX;
    350e:	e0 91 f1 00 	lds	r30, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003512 <.Loc.357>:
				Data.Bytes[1] = UEDATX;
    3512:	30 91 f1 00 	lds	r19, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003516 <.Loc.359>:
			
				return Data.Word;
    3516:	6e 2f       	mov	r22, r30
    3518:	73 2f       	mov	r23, r19

0000351a <.LBE286>:
							boot_page_fill(CurrFlashAddress.Long, Endpoint_Read_Word_LE());
    351a:	fc 01       	movw	r30, r24
    351c:	0b 01       	movw	r0, r22
    351e:	10 93 57 00 	sts	0x0057, r17	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    3522:	e8 95       	spm
    3524:	11 24       	eor	r1, r1

00003526 <.Loc.362>:
							WordsInFlashPage      += 1;
    3526:	2f 5f       	subi	r18, 0xFF	; 255

00003528 <.Loc.364>:
							CurrFlashAddress.Long += 2;
    3528:	6c 01       	movw	r12, r24

0000352a <.Loc.366>:
    352a:	7d 01       	movw	r14, r26
    352c:	f2 e0       	ldi	r31, 0x02	; 2
    352e:	cf 0e       	add	r12, r31
    3530:	d1 1c       	adc	r13, r1
    3532:	e1 1c       	adc	r14, r1
    3534:	f1 1c       	adc	r15, r1
    3536:	d7 01       	movw	r26, r14

00003538 <.Loc.367>:
    3538:	c6 01       	movw	r24, r12

0000353a <.LVL56>:
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
    353a:	20 34       	cpi	r18, 0x40	; 64
    353c:	11 f5       	brne	.+68     	; 0x3582 <.L137>

0000353e <.L73>:
								boot_page_write(CurrFlashPageStartAddress);
    353e:	f4 01       	movw	r30, r8
    3540:	00 93 57 00 	sts	0x0057, r16	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    3544:	e8 95       	spm

00003546 <.L79>:
								boot_spm_busy_wait();
    3546:	07 b6       	in	r0, 0x37	; 55
    3548:	00 fc       	sbrc	r0, 0
    354a:	fd cf       	rjmp	.-6      	; 0x3546 <.L79>

0000354c <.Loc.374>:
								if (WordsRemaining)
    354c:	41 15       	cp	r20, r1
    354e:	51 05       	cpc	r21, r1
    3550:	d9 f0       	breq	.+54     	; 0x3588 <.L78>

00003552 <.LVL57>:
									boot_page_erase(CurrFlashAddress.Long);
    3552:	f6 01       	movw	r30, r12
    3554:	70 92 57 00 	sts	0x0057, r7	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
    3558:	e8 95       	spm

0000355a <.L80>:
									boot_spm_busy_wait();
    355a:	37 b7       	in	r19, 0x37	; 55
    355c:	23 2f       	mov	r18, r19
    355e:	21 70       	andi	r18, 0x01	; 1
    3560:	30 fd       	sbrc	r19, 0
    3562:	fb cf       	rjmp	.-10     	; 0x355a <.L80>

00003564 <.Loc.382>:
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
    3564:	46 01       	movw	r8, r12
    3566:	10 c0       	rjmp	.+32     	; 0x3588 <.L78>

00003568 <.L72>:
					UEINTX &= ~(1 << RXOUTI);	
    3568:	30 91 e8 00 	lds	r19, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    356c:	3b 7f       	andi	r19, 0xFB	; 251
    356e:	30 93 e8 00 	sts	0x00E8, r19	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003572 <.L75>:
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    3572:	30 91 e8 00 	lds	r19, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003576 <.LBE290>:
								while (!(Endpoint_IsOUTReceived()))
    3576:	32 fd       	sbrc	r19, 2
    3578:	ca cf       	rjmp	.-108    	; 0x350e <.L77>

0000357a <.Loc.392>:
									if (USB_DeviceState == DEVICE_STATE_Unattached)
    357a:	3e b3       	in	r19, 0x1e	; 30

0000357c <.Loc.394>:
    357c:	31 11       	cpse	r19, r1
    357e:	f9 cf       	rjmp	.-14     	; 0x3572 <.L75>
    3580:	0d cf       	rjmp	.-486    	; 0x339c <.L46>

00003582 <.L137>:
							if ((WordsInFlashPage == (SPM_PAGESIZE >> 1)) || !(WordsRemaining))
    3582:	41 15       	cp	r20, r1
    3584:	51 05       	cpc	r21, r1
    3586:	d9 f2       	breq	.-74     	; 0x353e <.L73>

00003588 <.L78>:
									CurrFlashPageStartAddress = CurrFlashAddress.Long;
    3588:	ea 01       	movw	r28, r20
    358a:	a9 cf       	rjmp	.-174    	; 0x34de <.L71>

0000358c <.L88>:
					return UEBCLX;
    358c:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

00003590 <.LBE293>:
							if (!(Endpoint_BytesInEndpoint()))
    3590:	88 23       	and	r24, r24
    3592:	a1 f0       	breq	.+40     	; 0x35bc <.L83>

00003594 <.L87>:
						while (BytesRemaining--)
    3594:	21 97       	sbiw	r28, 0x01	; 1

00003596 <.LBB295>:
				return UEDATX;
    3596:	60 91 f1 00 	lds	r22, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000359a <.LBE295>:
							eeprom_write_byte((uint8_t*)StartAddr, Endpoint_Read_Byte());
    359a:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <StartAddr>
    359e:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <StartAddr+0x1>
    35a2:	3d d3       	rcall	.+1658   	; 0x3c1e <eeprom_write_byte>

000035a4 <.LVL63>:
							StartAddr++;
    35a4:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <StartAddr>
    35a8:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <StartAddr+0x1>
    35ac:	01 96       	adiw	r24, 0x01	; 1
    35ae:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <StartAddr+0x1>
    35b2:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <StartAddr>

000035b6 <.L70>:
						while (BytesRemaining--)
    35b6:	20 97       	sbiw	r28, 0x00	; 0
    35b8:	49 f7       	brne	.-46     	; 0x358c <.L88>
    35ba:	a2 cf       	rjmp	.-188    	; 0x3500 <.L82>

000035bc <.L83>:
					UEINTX &= ~(1 << RXOUTI);	
    35bc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    35c0:	8b 7f       	andi	r24, 0xFB	; 251
    35c2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000035c6 <.L84>:
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    35c6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000035ca <.LBE299>:
								while (!(Endpoint_IsOUTReceived()))
    35ca:	82 fd       	sbrc	r24, 2
    35cc:	e3 cf       	rjmp	.-58     	; 0x3594 <.L87>

000035ce <.Loc.422>:
									if (USB_DeviceState == DEVICE_STATE_Unattached)
    35ce:	8e b3       	in	r24, 0x1e	; 30

000035d0 <.Loc.424>:
    35d0:	81 11       	cpse	r24, r1
    35d2:	f9 cf       	rjmp	.-14     	; 0x35c6 <.L84>
    35d4:	e3 ce       	rjmp	.-570    	; 0x339c <.L46>

000035d6 <.L55>:
				UEINTX &= ~(1 << RXSTPI);
    35d6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    35da:	87 7f       	andi	r24, 0xF7	; 247
    35dc:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000035e0 <.LBB303>:
				PORTD &= ~LEDMask;
    35e0:	5d 98       	cbi	0x0b, 5	; 11

000035e2 <.LBE303>:
			PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;
    35e2:	83 e0       	ldi	r24, 0x03	; 3
    35e4:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <PulseMSRemaining>

000035e8 <.L89>:
				return ((UEINTX & (1 << TXINI))  ? true : false);
    35e8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000035ec <.LBE305>:
			while (!(Endpoint_IsINReady()))
    35ec:	80 ff       	sbrs	r24, 0
    35ee:	16 c0       	rjmp	.+44     	; 0x361c <.L90>

000035f0 <.Loc.443>:
			if (DFU_State != dfuUPLOAD_IDLE)
    35f0:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <DFU_State>

000035f4 <.Loc.445>:
    35f4:	89 30       	cpi	r24, 0x09	; 9
    35f6:	c9 f0       	breq	.+50     	; 0x362a <.L91>

000035f8 <.Loc.446>:
				if ((DFU_State == dfuERROR) && IS_ONEBYTE_COMMAND(SentCommand.Data, 0x01))       // Blank Check
    35f8:	8a 30       	cpi	r24, 0x0A	; 10
    35fa:	a1 f4       	brne	.+40     	; 0x3624 <.L92>

000035fc <.Loc.448>:
    35fc:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>
    3600:	81 30       	cpi	r24, 0x01	; 1
    3602:	81 f4       	brne	.+32     	; 0x3624 <.L92>

00003604 <.Loc.449>:
					Endpoint_Write_Word_LE(StartAddr);
    3604:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <StartAddr>
    3608:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <StartAddr+0x1>

0000360c <.LBB307>:
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
    360c:	90 93 f1 00 	sts	0x00F1, r25	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003610 <.L140>:
				UEDATX = Byte;
    3610:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003614 <.L93>:
					UEINTX &= ~(1 << TXINI);
    3614:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3618:	8e 7f       	andi	r24, 0xFE	; 254
    361a:	07 cf       	rjmp	.-498    	; 0x342a <.L142>

0000361c <.L90>:
				if (USB_DeviceState == DEVICE_STATE_Unattached)
    361c:	8e b3       	in	r24, 0x1e	; 30

0000361e <.Loc.465>:
    361e:	81 11       	cpse	r24, r1
    3620:	e3 cf       	rjmp	.-58     	; 0x35e8 <.L89>
    3622:	bc ce       	rjmp	.-648    	; 0x339c <.L46>

00003624 <.L92>:
					Endpoint_Write_Byte(ResponseByte);
    3624:	80 91 7e 01 	lds	r24, 0x017E	; 0x80017e <ResponseByte>
    3628:	f3 cf       	rjmp	.-26     	; 0x3610 <.L140>

0000362a <.L91>:
				uint16_t BytesRemaining = ((EndAddr - StartAddr) + 1);
    362a:	20 91 6c 01 	lds	r18, 0x016C	; 0x80016c <StartAddr>
    362e:	30 91 6d 01 	lds	r19, 0x016D	; 0x80016d <StartAddr+0x1>

00003632 <.Loc.469>:
    3632:	c0 91 6a 01 	lds	r28, 0x016A	; 0x80016a <EndAddr>
    3636:	d0 91 6b 01 	lds	r29, 0x016B	; 0x80016b <EndAddr+0x1>
    363a:	21 96       	adiw	r28, 0x01	; 1
    363c:	c2 1b       	sub	r28, r18
    363e:	d3 0b       	sbc	r29, r19

00003640 <.LVL71>:
				if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x00))            // Read FLASH
    3640:	80 91 74 01 	lds	r24, 0x0174	; 0x800174 <SentCommand+0x1>

00003644 <.Loc.472>:
    3644:	81 11       	cpse	r24, r1
    3646:	31 c0       	rjmp	.+98     	; 0x36aa <.L94>

00003648 <.LBB313>:
					uint16_t WordsRemaining = (BytesRemaining >> 1);
    3648:	d6 95       	lsr	r29
    364a:	c7 95       	ror	r28

0000364c <.LVL72>:
					} CurrFlashAddress = {.Words = {StartAddr, Flash64KBPage}};
    364c:	c9 01       	movw	r24, r18

0000364e <.Loc.477>:
    364e:	20 91 6e 01 	lds	r18, 0x016E	; 0x80016e <Flash64KBPage>

00003652 <.LVL74>:
    3652:	a2 2f       	mov	r26, r18

00003654 <.Loc.479>:
    3654:	b0 e0       	ldi	r27, 0x00	; 0

00003656 <.L95>:
					while (WordsRemaining--)
    3656:	21 97       	sbiw	r28, 0x01	; 1
    3658:	60 f4       	brcc	.+24     	; 0x3672 <.L100>

0000365a <.Loc.483>:
					StartAddr = EndAddr;
    365a:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <EndAddr>
    365e:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <EndAddr+0x1>
    3662:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <StartAddr+0x1>
    3666:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <StartAddr>

0000366a <.L101>:
				DFU_State = dfuIDLE;
    366a:	82 e0       	ldi	r24, 0x02	; 2
    366c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <DFU_State>
    3670:	d1 cf       	rjmp	.-94     	; 0x3614 <.L93>

00003672 <.L100>:
					return UEBCLX;
    3672:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

00003676 <.LBE314>:
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
    3676:	20 32       	cpi	r18, 0x20	; 32
    3678:	59 f0       	breq	.+22     	; 0x3690 <.L96>

0000367a <.L98>:
							Endpoint_Write_Word_LE(pgm_read_word(CurrFlashAddress.Long));							
    367a:	fc 01       	movw	r30, r24
    367c:	25 91       	lpm	r18, Z+
    367e:	34 91       	lpm	r19, Z

00003680 <.LBB317>:
				UEDATX = (Word & 0xFF);
    3680:	20 93 f1 00 	sts	0x00F1, r18	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003684 <.Loc.502>:
				UEDATX = (Word >> 8);
    3684:	30 93 f1 00 	sts	0x00F1, r19	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003688 <.LBE317>:
						CurrFlashAddress.Long += 2;
    3688:	02 96       	adiw	r24, 0x02	; 2
    368a:	a1 1d       	adc	r26, r1
    368c:	b1 1d       	adc	r27, r1

0000368e <.LVL82>:
    368e:	e3 cf       	rjmp	.-58     	; 0x3656 <.L95>

00003690 <.L96>:
					UEINTX &= ~(1 << TXINI);
    3690:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3694:	2e 7f       	andi	r18, 0xFE	; 254
    3696:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000369a <.L97>:
				return ((UEINTX & (1 << TXINI))  ? true : false);
    369a:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000369e <.LBE321>:
							while (!(Endpoint_IsINReady()))
    369e:	20 fd       	sbrc	r18, 0
    36a0:	ec cf       	rjmp	.-40     	; 0x367a <.L98>

000036a2 <.Loc.517>:
								if (USB_DeviceState == DEVICE_STATE_Unattached)
    36a2:	2e b3       	in	r18, 0x1e	; 30

000036a4 <.Loc.519>:
    36a4:	21 11       	cpse	r18, r1
    36a6:	f9 cf       	rjmp	.-14     	; 0x369a <.L97>
    36a8:	79 ce       	rjmp	.-782    	; 0x339c <.L46>

000036aa <.L94>:
				else if (IS_ONEBYTE_COMMAND(SentCommand.Data, 0x02))       // Read EEPROM
    36aa:	82 30       	cpi	r24, 0x02	; 2
    36ac:	f1 f6       	brne	.-68     	; 0x366a <.L101>

000036ae <.L102>:
					while (BytesRemaining--)
    36ae:	20 97       	sbiw	r28, 0x00	; 0
    36b0:	e1 f2       	breq	.-72     	; 0x366a <.L101>

000036b2 <.LBB324>:
					return UEBCLX;
    36b2:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

000036b6 <.LBE324>:
						if (Endpoint_BytesInEndpoint() == FIXED_CONTROL_ENDPOINT_SIZE)
    36b6:	80 32       	cpi	r24, 0x20	; 32
    36b8:	91 f0       	breq	.+36     	; 0x36de <.L103>

000036ba <.L105>:
						Endpoint_Write_Byte(eeprom_read_byte((uint8_t*)StartAddr));
    36ba:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <StartAddr>
    36be:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <StartAddr+0x1>
    36c2:	a5 d2       	rcall	.+1354   	; 0x3c0e <eeprom_read_byte>

000036c4 <.LBB326>:
				UEDATX = Byte;
    36c4:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

000036c8 <.LBE326>:
						StartAddr++;
    36c8:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <StartAddr>
    36cc:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <StartAddr+0x1>
    36d0:	01 96       	adiw	r24, 0x01	; 1
    36d2:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <StartAddr+0x1>
    36d6:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <StartAddr>
    36da:	21 97       	sbiw	r28, 0x01	; 1

000036dc <.LVL88>:
    36dc:	e8 cf       	rjmp	.-48     	; 0x36ae <.L102>

000036de <.L103>:
					UEINTX &= ~(1 << TXINI);
    36de:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    36e2:	8e 7f       	andi	r24, 0xFE	; 254
    36e4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000036e8 <.L104>:
				return ((UEINTX & (1 << TXINI))  ? true : false);
    36e8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000036ec <.LBE330>:
							while (!(Endpoint_IsINReady()))
    36ec:	80 fd       	sbrc	r24, 0
    36ee:	e5 cf       	rjmp	.-54     	; 0x36ba <.L105>

000036f0 <.Loc.547>:
								if (USB_DeviceState == DEVICE_STATE_Unattached)
    36f0:	8e b3       	in	r24, 0x1e	; 30

000036f2 <.Loc.549>:
    36f2:	81 11       	cpse	r24, r1
    36f4:	f9 cf       	rjmp	.-14     	; 0x36e8 <.L104>
    36f6:	52 ce       	rjmp	.-860    	; 0x339c <.L46>

000036f8 <.L56>:
				UEINTX &= ~(1 << RXSTPI);
    36f8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    36fc:	87 7f       	andi	r24, 0xF7	; 247
    36fe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003702 <.LBE332>:
			Endpoint_Write_Byte(DFU_Status);
    3702:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <DFU_Status>

00003706 <.LBB334>:
				UEDATX = Byte;
    3706:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000370a <.LBB336>:
    370a:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000370e <.LBB338>:
				UEDATX = (Word & 0xFF);
    370e:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003712 <.Loc.569>:
				UEDATX = (Word >> 8);
    3712:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003716 <.LBE338>:
			Endpoint_Write_Byte(DFU_State);
    3716:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <DFU_State>

0000371a <.LBB340>:
				UEDATX = Byte;
    371a:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000371e <.LBB342>:
    371e:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003722 <.LBB344>:
					UEINTX &= ~(1 << TXINI);
    3722:	78 cf       	rjmp	.-272    	; 0x3614 <.L93>

00003724 <.L53>:
				UEINTX &= ~(1 << RXSTPI);
    3724:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3728:	87 7f       	andi	r24, 0xF7	; 247
    372a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000372e <.LBE346>:
			DFU_Status = OK;
    372e:	10 92 71 01 	sts	0x0171, r1	; 0x800171 <DFU_Status>

00003732 <.Loc.591>:
			Endpoint_ClearStatusStage();
    3732:	7d ce       	rjmp	.-774    	; 0x342e <.L141>

00003734 <.L59>:
    3734:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3738:	87 7f       	andi	r24, 0xF7	; 247
    373a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000373e <.LBE348>:
			Endpoint_Write_Byte(DFU_State);
    373e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <DFU_State>

00003742 <.LBB350>:
				UEDATX = Byte;
    3742:	66 cf       	rjmp	.-308    	; 0x3610 <.L140>

00003744 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    void** const DescriptorAddress)
{
    3744:	fa 01       	movw	r30, r20

00003746 <.Loc.2>:
	const uint8_t  DescriptorType   = (wValue >> 8);
    3746:	29 2f       	mov	r18, r25
    3748:	30 e0       	ldi	r19, 0x00	; 0

0000374a <.LVL1>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	void*    Address = NULL;
	uint16_t Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
    374a:	22 30       	cpi	r18, 0x02	; 2
    374c:	31 05       	cpc	r19, r1
    374e:	d9 f0       	breq	.+54     	; 0x3786 <.L5>
    3750:	23 30       	cpi	r18, 0x03	; 3
    3752:	31 05       	cpc	r19, r1
    3754:	51 f0       	breq	.+20     	; 0x376a <.L3>
    3756:	21 30       	cpi	r18, 0x01	; 1
    3758:	31 05       	cpc	r19, r1
    375a:	d1 f4       	brne	.+52     	; 0x3790 <.L6>
    375c:	82 e1       	ldi	r24, 0x12	; 18
    375e:	90 e0       	ldi	r25, 0x00	; 0

00003760 <.LVL2>:
    3760:	2f e4       	ldi	r18, 0x4F	; 79
    3762:	31 e0       	ldi	r19, 0x01	; 1

00003764 <.L2>:
			}
			
			break;
	}
	
	*DescriptorAddress = Address;
    3764:	31 83       	std	Z+1, r19	; 0x01
    3766:	20 83       	st	Z, r18

00003768 <.Loc.11>:
	return Size;
}
    3768:	08 95       	ret

0000376a <.L3>:
			if (!(DescriptorNumber))
    376a:	81 11       	cpse	r24, r1
    376c:	06 c0       	rjmp	.+12     	; 0x377a <.L4>

0000376e <.LVL5>:
				Size    = LanguageString.Header.Size;
    376e:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <LanguageString>

00003772 <.LVL6>:
    3772:	90 e0       	ldi	r25, 0x00	; 0

00003774 <.LVL7>:
				Address = &LanguageString;
    3774:	20 e3       	ldi	r18, 0x30	; 48
    3776:	31 e0       	ldi	r19, 0x01	; 1

00003778 <.LVL8>:
    3778:	f5 cf       	rjmp	.-22     	; 0x3764 <.L2>

0000377a <.L4>:
				Size    = ProductString.Header.Size;
    377a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <ProductString>

0000377e <.LVL10>:
    377e:	90 e0       	ldi	r25, 0x00	; 0

00003780 <.LVL11>:
				Address = &ProductString;
    3780:	22 e0       	ldi	r18, 0x02	; 2
    3782:	31 e0       	ldi	r19, 0x01	; 1

00003784 <.LVL12>:
    3784:	ef cf       	rjmp	.-34     	; 0x3764 <.L2>

00003786 <.L5>:
			Size    = sizeof(USB_Descriptor_Configuration_t);
    3786:	8b e1       	ldi	r24, 0x1B	; 27
    3788:	90 e0       	ldi	r25, 0x00	; 0

0000378a <.LVL14>:
			Address = &ConfigurationDescriptor;
    378a:	24 e3       	ldi	r18, 0x34	; 52
    378c:	31 e0       	ldi	r19, 0x01	; 1

0000378e <.LVL15>:
    378e:	ea cf       	rjmp	.-44     	; 0x3764 <.L2>

00003790 <.L6>:
	uint16_t Size    = NO_DESCRIPTOR;
    3790:	90 e0       	ldi	r25, 0x00	; 0
    3792:	80 e0       	ldi	r24, 0x00	; 0

00003794 <.LVL17>:
	void*    Address = NULL;
    3794:	30 e0       	ldi	r19, 0x00	; 0
    3796:	20 e0       	ldi	r18, 0x00	; 0

00003798 <.LVL18>:
    3798:	e5 cf       	rjmp	.-54     	; 0x3764 <.L2>

0000379a <Endpoint_ConfigureEndpoint_Prv>:
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    379a:	eb ee       	ldi	r30, 0xEB	; 235
    379c:	f0 e0       	ldi	r31, 0x00	; 0
    379e:	80 81       	ld	r24, Z

000037a0 <.LVL8>:
    37a0:	81 60       	ori	r24, 0x01	; 1
    37a2:	80 83       	st	Z, r24

000037a4 <.LBE187>:
                                    const uint8_t UECFG1XData)
{
	Endpoint_SelectEndpoint(Number);
	Endpoint_EnableEndpoint();

	UECFG1X = 0;
    37a4:	ed ee       	ldi	r30, 0xED	; 237
    37a6:	f0 e0       	ldi	r31, 0x00	; 0
    37a8:	10 82       	st	Z, r1

000037aa <.Loc.28>:

	UECFG0X = UECFG0XData;
    37aa:	60 93 ec 00 	sts	0x00EC, r22	; 0x8000ec <__DATA_REGION_ORIGIN__+0x8c>

000037ae <.Loc.30>:
	UECFG1X = UECFG1XData;
    37ae:	40 83       	st	Z, r20

000037b0 <.LBB189>:
			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    37b0:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__DATA_REGION_ORIGIN__+0x8e>

000037b4 <.LBE189>:

	return Endpoint_IsConfigured();
}
    37b4:	88 1f       	adc	r24, r24
    37b6:	88 27       	eor	r24, r24
    37b8:	88 1f       	adc	r24, r24
    37ba:	08 95       	ret

000037bc <Endpoint_ClearEndpoints>:

void Endpoint_ClearEndpoints(void)
{
	UEINT = 0;
    37bc:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__DATA_REGION_ORIGIN__+0x94>

000037c0 <.LBB191>:

	for (uint8_t EPNum = 0; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
	{
		Endpoint_SelectEndpoint(EPNum);	
		UEIENX  = 0;
    37c0:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__DATA_REGION_ORIGIN__+0x90>

000037c4 <.Loc.48>:
		UEINTX  = 0;
    37c4:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000037c8 <.Loc.50>:
		UECFG1X = 0;
    37c8:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__DATA_REGION_ORIGIN__+0x8d>

000037cc <.LBB192>:
				UECONX &= ~(1 << EPEN);
    37cc:	eb ee       	ldi	r30, 0xEB	; 235
    37ce:	f0 e0       	ldi	r31, 0x00	; 0
    37d0:	80 81       	ld	r24, Z
    37d2:	8e 7f       	andi	r24, 0xFE	; 254
    37d4:	80 83       	st	Z, r24

000037d6 <.LBE192>:
		Endpoint_DisableEndpoint();
	}
}
    37d6:	08 95       	ret

000037d8 <Endpoint_ClearStatusStage>:

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    37d8:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <USB_ControlRequest>
    37dc:	87 ff       	sbrs	r24, 7
    37de:	11 c0       	rjmp	.+34     	; 0x3802 <.L8>

000037e0 <.L7>:
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    37e0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000037e4 <.LBE195>:
	{
		while (!(Endpoint_IsOUTReceived()))
    37e4:	82 ff       	sbrs	r24, 2
    37e6:	06 c0       	rjmp	.+12     	; 0x37f4 <.L10>

000037e8 <.LBB197>:
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
				#else
					UEINTX &= ~(1 << RXOUTI);	
    37e8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    37ec:	8b 7f       	andi	r24, 0xFB	; 251

000037ee <.L19>:
					UEINTX &= ~(1 << TXINI);
    37ee:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

000037f2 <.Loc.72>:
			}
    37f2:	03 c0       	rjmp	.+6      	; 0x37fa <.L6>

000037f4 <.L10>:
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    37f4:	8e b3       	in	r24, 0x1e	; 30

000037f6 <.Loc.75>:
    37f6:	81 11       	cpse	r24, r1
    37f8:	f3 cf       	rjmp	.-26     	; 0x37e0 <.L7>

000037fa <.L6>:
			  return;
		}
		
		Endpoint_ClearIN();
	}
}
    37fa:	08 95       	ret

000037fc <.L11>:
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    37fc:	8e b3       	in	r24, 0x1e	; 30

000037fe <.Loc.79>:
    37fe:	88 23       	and	r24, r24
    3800:	e1 f3       	breq	.-8      	; 0x37fa <.L6>

00003802 <.L8>:
				return ((UEINTX & (1 << TXINI))  ? true : false);
    3802:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003806 <.LBE202>:
		while (!(Endpoint_IsINReady()))
    3806:	80 ff       	sbrs	r24, 0
    3808:	f9 cf       	rjmp	.-14     	; 0x37fc <.L11>

0000380a <.LBB204>:
					UEINTX &= ~(1 << TXINI);
    380a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    380e:	8e 7f       	andi	r24, 0xFE	; 254
    3810:	ee cf       	rjmp	.-36     	; 0x37ee <.L19>

00003812 <Endpoint_Write_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (const void* Buffer,
                            uint16_t Length)
{
    3812:	9b 01       	movw	r18, r22

00003814 <.LVL12>:
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;
	
	if (Length > USB_ControlRequest.wLength)
    3814:	40 91 87 01 	lds	r20, 0x0187	; 0x800187 <USB_ControlRequest+0x6>
    3818:	50 91 88 01 	lds	r21, 0x0188	; 0x800188 <USB_ControlRequest+0x7>

0000381c <.Loc.95>:
    381c:	46 17       	cp	r20, r22
    381e:	57 07       	cpc	r21, r23
    3820:	98 f0       	brcs	.+38     	; 0x3848 <.L32>

00003822 <.Loc.96>:
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    3822:	67 2b       	or	r22, r23
    3824:	29 f4       	brne	.+10     	; 0x3830 <.L21>

00003826 <.LBB205>:
    3826:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    382a:	4e 7f       	andi	r20, 0xFE	; 254
    382c:	40 93 e8 00 	sts	0x00E8, r20	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003830 <.L21>:
		{
			uint8_t BytesInEndpoint = Endpoint_BytesInEndpoint();
		
			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    3830:	50 e0       	ldi	r21, 0x00	; 0

00003832 <.L25>:
	while (Length || LastPacketFull)
    3832:	21 15       	cp	r18, r1
    3834:	31 05       	cpc	r19, r1
    3836:	51 f4       	brne	.+20     	; 0x384c <.L30>

00003838 <.Loc.106>:
    3838:	51 11       	cpse	r21, r1
    383a:	08 c0       	rjmp	.+16     	; 0x384c <.L30>

0000383c <.L43>:
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    383c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003840 <.LBE214>:
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}
	
	while (!(Endpoint_IsOUTReceived()))
    3840:	82 ff       	sbrs	r24, 2
    3842:	30 c0       	rjmp	.+96     	; 0x38a4 <.L31>

00003844 <.Loc.112>:
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    3844:	80 e0       	ldi	r24, 0x00	; 0
    3846:	08 95       	ret

00003848 <.L32>:
    3848:	9a 01       	movw	r18, r20

0000384a <.LVL16>:
    384a:	f2 cf       	rjmp	.-28     	; 0x3830 <.L21>

0000384c <.L30>:
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    384c:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003850 <.LBE216>:
		if (Endpoint_IsSETUPReceived())
    3850:	43 fd       	sbrc	r20, 3
    3852:	30 c0       	rjmp	.+96     	; 0x38b4 <.L33>

00003854 <.LBB218>:
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    3854:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003858 <.LBE218>:
		if (Endpoint_IsOUTReceived())
    3858:	42 fd       	sbrc	r20, 2
    385a:	f0 cf       	rjmp	.-32     	; 0x383c <.L43>

0000385c <.Loc.125>:
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    385c:	4e b3       	in	r20, 0x1e	; 30

0000385e <.Loc.127>:
    385e:	44 23       	and	r20, r20
    3860:	59 f1       	breq	.+86     	; 0x38b8 <.L36>

00003862 <.Loc.128>:
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
    3862:	4e b3       	in	r20, 0x1e	; 30

00003864 <.Loc.130>:
    3864:	45 30       	cpi	r20, 0x05	; 5
    3866:	21 f1       	breq	.+72     	; 0x38b0 <.L37>

00003868 <.LBB220>:
				return ((UEINTX & (1 << TXINI))  ? true : false);
    3868:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000386c <.LBE220>:
		if (Endpoint_IsINReady())
    386c:	40 ff       	sbrs	r20, 0
    386e:	e1 cf       	rjmp	.-62     	; 0x3832 <.L25>

00003870 <.LBB208>:
					return UEBCLX;
    3870:	40 91 f2 00 	lds	r20, 0x00F2	; 0x8000f2 <__DATA_REGION_ORIGIN__+0x92>

00003874 <.L26>:
			while (Length && (BytesInEndpoint < USB_ControlEndpointSize))
    3874:	21 15       	cp	r18, r1
    3876:	31 05       	cpc	r19, r1
    3878:	11 f0       	breq	.+4      	; 0x387e <.L27>

0000387a <.Loc.143>:
    387a:	40 32       	cpi	r20, 0x20	; 32
    387c:	50 f0       	brcs	.+20     	; 0x3892 <.L28>

0000387e <.L27>:
			LastPacketFull = (BytesInEndpoint == USB_ControlEndpointSize);
    387e:	51 e0       	ldi	r21, 0x01	; 1

00003880 <.LVL19>:
    3880:	40 32       	cpi	r20, 0x20	; 32
    3882:	09 f0       	breq	.+2      	; 0x3886 <.L29>
    3884:	50 e0       	ldi	r21, 0x00	; 0

00003886 <.L29>:
					UEINTX &= ~(1 << TXINI);
    3886:	40 91 e8 00 	lds	r20, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

0000388a <.LVL21>:
    388a:	4e 7f       	andi	r20, 0xFE	; 254
    388c:	40 93 e8 00 	sts	0x00E8, r20	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003890 <.LVL22>:
			}
    3890:	d0 cf       	rjmp	.-96     	; 0x3832 <.L25>

00003892 <.L28>:
				TEMPLATE_TRANSFER_BYTE(DataStream);
    3892:	fc 01       	movw	r30, r24

00003894 <.LVL24>:
    3894:	81 91       	ld	r24, Z+

00003896 <.LBB212>:
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
    3896:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

0000389a <.LBE212>:
				Length--;
    389a:	21 50       	subi	r18, 0x01	; 1
    389c:	31 09       	sbc	r19, r1

0000389e <.Loc.162>:
				BytesInEndpoint++;
    389e:	4f 5f       	subi	r20, 0xFF	; 255

000038a0 <.Loc.164>:
				TEMPLATE_TRANSFER_BYTE(DataStream);
    38a0:	cf 01       	movw	r24, r30
    38a2:	e8 cf       	rjmp	.-48     	; 0x3874 <.L26>

000038a4 <.L31>:
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    38a4:	8e b3       	in	r24, 0x1e	; 30

000038a6 <.Loc.168>:
    38a6:	88 23       	and	r24, r24
    38a8:	39 f0       	breq	.+14     	; 0x38b8 <.L36>

000038aa <.Loc.169>:
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
    38aa:	8e b3       	in	r24, 0x1e	; 30

000038ac <.Loc.171>:
    38ac:	85 30       	cpi	r24, 0x05	; 5
    38ae:	31 f6       	brne	.-116    	; 0x383c <.L43>

000038b0 <.L37>:
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    38b0:	83 e0       	ldi	r24, 0x03	; 3

000038b2 <.Loc.173>:
}
    38b2:	08 95       	ret

000038b4 <.L33>:
		  return ENDPOINT_RWCSTREAM_HostAborted;
    38b4:	81 e0       	ldi	r24, 0x01	; 1

000038b6 <.LVL31>:
    38b6:	08 95       	ret

000038b8 <.L36>:
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    38b8:	82 e0       	ldi	r24, 0x02	; 2
    38ba:	08 95       	ret

000038bc <USB_ResetInterface>:
	#endif
}

void USB_ResetInterface(void)
{
	USB_INT_DisableAllInterrupts();
    38bc:	54 d0       	rcall	.+168    	; 0x3966 <USB_INT_DisableAllInterrupts>

000038be <.LVL0>:
	USB_INT_ClearAllInterrupts();
    38be:	56 d0       	rcall	.+172    	; 0x396c <USB_INT_ClearAllInterrupts>

000038c0 <.LVL1>:
	#if defined(USB_CAN_BE_HOST)
	USB_HostState   = HOST_STATE_Unattached;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	USB_DeviceState = DEVICE_STATE_Unattached;
    38c0:	1e ba       	out	0x1e, r1	; 30

000038c2 <.Loc.5>:
	USB_ConfigurationNumber  = 0;
    38c2:	10 92 7f 01 	sts	0x017F, r1	; 0x80017f <USB_ConfigurationNumber>

000038c6 <.LBB22>:
	#if !defined(__DOXYGEN__)
		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
    38c6:	84 e0       	ldi	r24, 0x04	; 4
    38c8:	89 bd       	out	0x29, r24	; 41

000038ca <.Loc.12>:
				PLLCSR |= (1 << PLLE);
    38ca:	89 b5       	in	r24, 0x29	; 41
    38cc:	82 60       	ori	r24, 0x02	; 2
    38ce:	89 bd       	out	0x29, r24	; 41

000038d0 <.L2>:
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
    38d0:	09 b4       	in	r0, 0x29	; 41
    38d2:	00 fe       	sbrs	r0, 0
    38d4:	fd cf       	rjmp	.-6      	; 0x38d0 <.L2>

000038d6 <.LBB26>:
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
    38d6:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>

000038da <.LVL2>:
				
				USBCON = (Temp & ~(1 << USBE));
    38da:	98 2f       	mov	r25, r24
    38dc:	9f 77       	andi	r25, 0x7F	; 127

000038de <.Loc.25>:
    38de:	90 93 d8 00 	sts	0x00D8, r25	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>

000038e2 <.Loc.26>:
				USBCON = (Temp |  (1 << USBE));
    38e2:	80 68       	ori	r24, 0x80	; 128

000038e4 <.LVL3>:
    38e4:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>

000038e8 <.LBB28>:
				REGCR   &= ~(1 << REGDIS);
    38e8:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>
    38ec:	8e 7f       	andi	r24, 0xFE	; 254
    38ee:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__DATA_REGION_ORIGIN__+0x3>

000038f2 <.LBB30>:
				USBCON  &= ~(1 << FRZCLK);
    38f2:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    38f6:	8f 7d       	andi	r24, 0xDF	; 223
    38f8:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>

000038fc <.LBB32>:
				UDCON  &= ~(1 << DETACH);
    38fc:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__DATA_REGION_ORIGIN__+0x80>
    3900:	8e 7f       	andi	r24, 0xFE	; 254
    3902:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <__DATA_REGION_ORIGIN__+0x80>

00003906 <.LBE32>:
	#endif

	USB_Attach();
	
	#if defined(USB_DEVICE_ONLY)
	USB_INT_Clear(USB_INT_SUSPEND);
    3906:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    390a:	8e 7f       	andi	r24, 0xFE	; 254
    390c:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003910 <.Loc.45>:
	USB_INT_Enable(USB_INT_SUSPEND);
    3910:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    3914:	81 60       	ori	r24, 0x01	; 1
    3916:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

0000391a <.Loc.48>:
	USB_INT_Clear(USB_INT_EORSTI);
    391a:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    391e:	87 7f       	andi	r24, 0xF7	; 247
    3920:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003924 <.Loc.51>:
	USB_INT_Enable(USB_INT_EORSTI);
    3924:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    3928:	88 60       	ori	r24, 0x08	; 8
    392a:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

0000392e <.Loc.54>:
		
		USB_INT_Enable(USB_INT_SRPI);
		USB_INT_Enable(USB_INT_BCERRI);
	}
	#endif
}
    392e:	08 95       	ret

00003930 <USB_Init>:
	USB_ResetInterface();
    3930:	c5 df       	rcall	.-118    	; 0x38bc <USB_ResetInterface>

00003932 <.LVL4>:
	USB_IsInitialized = true;
    3932:	81 e0       	ldi	r24, 0x01	; 1
    3934:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <USB_IsInitialized>

00003938 <.Loc.60>:
}
    3938:	08 95       	ret

0000393a <USB_ShutDown>:
	USB_ResetInterface();
    393a:	c0 df       	rcall	.-128    	; 0x38bc <USB_ResetInterface>

0000393c <.LBB34>:
				UDCON  |=  (1 << DETACH);
    393c:	e0 ee       	ldi	r30, 0xE0	; 224
    393e:	f0 e0       	ldi	r31, 0x00	; 0
    3940:	80 81       	ld	r24, Z
    3942:	81 60       	ori	r24, 0x01	; 1
    3944:	80 83       	st	Z, r24

00003946 <.LBB36>:
				USBCON  &= ~(1 << USBE);
    3946:	e8 ed       	ldi	r30, 0xD8	; 216
    3948:	f0 e0       	ldi	r31, 0x00	; 0
    394a:	80 81       	ld	r24, Z
    394c:	8f 77       	andi	r24, 0x7F	; 127
    394e:	80 83       	st	Z, r24

00003950 <.LBE36>:
	USB_INT_DisableAllInterrupts();
    3950:	0a d0       	rcall	.+20     	; 0x3966 <USB_INT_DisableAllInterrupts>

00003952 <.LVL6>:
	USB_INT_ClearAllInterrupts();
    3952:	0c d0       	rcall	.+24     	; 0x396c <USB_INT_ClearAllInterrupts>

00003954 <.LBB38>:
				PLLCSR  = 0;
    3954:	19 bc       	out	0x29, r1	; 41

00003956 <.LBB40>:
				REGCR   |=  (1 << REGDIS);
    3956:	e3 e6       	ldi	r30, 0x63	; 99
    3958:	f0 e0       	ldi	r31, 0x00	; 0
    395a:	80 81       	ld	r24, Z
    395c:	81 60       	ori	r24, 0x01	; 1
    395e:	80 83       	st	Z, r24

00003960 <.LBE40>:
	USB_IsInitialized = false;
    3960:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <USB_IsInitialized>

00003964 <.Loc.84>:
}
    3964:	08 95       	ret

00003966 <USB_INT_DisableAllInterrupts>:
	UHIEN   = 0;
	OTGIEN  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    3966:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

0000396a <.Loc.3>:
	#endif
}
    396a:	08 95       	ret

0000396c <USB_INT_ClearAllInterrupts>:
	UHINT   = 0;
	OTGINT  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
    396c:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003970 <.Loc.7>:
	#endif
}
    3970:	08 95       	ret

00003972 <__vector_11>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    3972:	1f 92       	push	r1

00003974 <.LCFI0>:
    3974:	0f 92       	push	r0

00003976 <.LCFI1>:
    3976:	0f b6       	in	r0, 0x3f	; 63
    3978:	0f 92       	push	r0
    397a:	11 24       	eor	r1, r1
    397c:	2f 93       	push	r18

0000397e <.LCFI2>:
    397e:	3f 93       	push	r19

00003980 <.LCFI3>:
    3980:	4f 93       	push	r20

00003982 <.LCFI4>:
    3982:	5f 93       	push	r21

00003984 <.LCFI5>:
    3984:	6f 93       	push	r22

00003986 <.LCFI6>:
    3986:	7f 93       	push	r23

00003988 <.LCFI7>:
    3988:	8f 93       	push	r24

0000398a <.LCFI8>:
    398a:	9f 93       	push	r25

0000398c <.LCFI9>:
    398c:	af 93       	push	r26

0000398e <.LCFI10>:
    398e:	bf 93       	push	r27

00003990 <.LCFI11>:
    3990:	ef 93       	push	r30

00003992 <.LCFI12>:
    3992:	ff 93       	push	r31

00003994 <.LCFI13>:
			EVENT_USB_Device_Disconnect();
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPEND) && USB_INT_IsEnabled(USB_INT_SUSPEND))
    3994:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003998 <.Loc.11>:
    3998:	80 ff       	sbrs	r24, 0
    399a:	1b c0       	rjmp	.+54     	; 0x39d2 <.L4>

0000399c <.Loc.12>:
    399c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

000039a0 <.Loc.13>:
    39a0:	80 ff       	sbrs	r24, 0
    39a2:	17 c0       	rjmp	.+46     	; 0x39d2 <.L4>

000039a4 <.Loc.14>:
	{
		USB_INT_Clear(USB_INT_SUSPEND);
    39a4:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    39a8:	8e 7f       	andi	r24, 0xFE	; 254
    39aa:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

000039ae <.Loc.16>:

		USB_INT_Disable(USB_INT_SUSPEND);
    39ae:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    39b2:	8e 7f       	andi	r24, 0xFE	; 254
    39b4:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

000039b8 <.Loc.19>:
		USB_INT_Enable(USB_INT_WAKEUP);
    39b8:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    39bc:	80 61       	ori	r24, 0x10	; 16
    39be:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

000039c2 <.LBB30>:
				USBCON  |=  (1 << FRZCLK);
    39c2:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    39c6:	80 62       	ori	r24, 0x20	; 32
    39c8:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>

000039cc <.LBB32>:
				PLLCSR  = 0;
    39cc:	19 bc       	out	0x29, r1	; 41

000039ce <.LBE32>:
		
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		  USB_PLL_Off();

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
    39ce:	1e ba       	out	0x1e, r1	; 30

000039d0 <.Loc.34>:
		EVENT_USB_Device_Disconnect();
    39d0:	0f d1       	rcall	.+542    	; 0x3bf0 <USB_Event_Stub>

000039d2 <.L4>:
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUP) && USB_INT_IsEnabled(USB_INT_WAKEUP))
    39d2:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

000039d6 <.Loc.37>:
    39d6:	84 ff       	sbrs	r24, 4
    39d8:	27 c0       	rjmp	.+78     	; 0x3a28 <.L5>

000039da <.Loc.38>:
    39da:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

000039de <.Loc.39>:
    39de:	84 ff       	sbrs	r24, 4
    39e0:	23 c0       	rjmp	.+70     	; 0x3a28 <.L5>

000039e2 <.LBB34>:
				PLLCSR  = USB_PLL_PSC;
    39e2:	84 e0       	ldi	r24, 0x04	; 4
    39e4:	89 bd       	out	0x29, r24	; 41

000039e6 <.Loc.45>:
				PLLCSR |= (1 << PLLE);
    39e6:	89 b5       	in	r24, 0x29	; 41
    39e8:	82 60       	ori	r24, 0x02	; 2
    39ea:	89 bd       	out	0x29, r24	; 41

000039ec <.L6>:
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    39ec:	09 b4       	in	r0, 0x29	; 41
    39ee:	00 fe       	sbrs	r0, 0
    39f0:	fd cf       	rjmp	.-6      	; 0x39ec <.L6>

000039f2 <.LBB38>:
				USBCON  &= ~(1 << FRZCLK);
    39f2:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>
    39f6:	8f 7d       	andi	r24, 0xDF	; 223
    39f8:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__DATA_REGION_ORIGIN__+0x78>

000039fc <.LBE38>:
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUP);
    39fc:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    3a00:	8f 7e       	andi	r24, 0xEF	; 239
    3a02:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003a06 <.Loc.58>:

		USB_INT_Disable(USB_INT_WAKEUP);
    3a06:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    3a0a:	8f 7e       	andi	r24, 0xEF	; 239
    3a0c:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

00003a10 <.Loc.61>:
		USB_INT_Enable(USB_INT_SUSPEND);
    3a10:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    3a14:	81 60       	ori	r24, 0x01	; 1
    3a16:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

00003a1a <.Loc.64>:
		
		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    3a1a:	80 91 7f 01 	lds	r24, 0x017F	; 0x80017f <USB_ConfigurationNumber>
    3a1e:	81 11       	cpse	r24, r1
    3a20:	48 c0       	rjmp	.+144    	; 0x3ab2 <.L10>
    3a22:	81 e0       	ldi	r24, 0x01	; 1

00003a24 <.L7>:
    3a24:	8e bb       	out	0x1e, r24	; 30

00003a26 <.Loc.68>:
		EVENT_USB_Device_Connect();
    3a26:	e4 d0       	rcall	.+456    	; 0x3bf0 <USB_Event_Stub>

00003a28 <.L5>:
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
		EVENT_USB_Device_WakeUp();		
		#endif
	}
   
	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    3a28:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003a2c <.Loc.71>:
    3a2c:	83 ff       	sbrs	r24, 3
    3a2e:	22 c0       	rjmp	.+68     	; 0x3a74 <.L8>

00003a30 <.Loc.72>:
    3a30:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

00003a34 <.Loc.73>:
    3a34:	83 ff       	sbrs	r24, 3
    3a36:	1e c0       	rjmp	.+60     	; 0x3a74 <.L8>

00003a38 <.Loc.74>:
	{
		USB_INT_Clear(USB_INT_EORSTI);
    3a38:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    3a3c:	87 7f       	andi	r24, 0xF7	; 247
    3a3e:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003a42 <.Loc.76>:

		USB_DeviceState         = DEVICE_STATE_Default;
    3a42:	82 e0       	ldi	r24, 0x02	; 2
    3a44:	8e bb       	out	0x1e, r24	; 30

00003a46 <.Loc.79>:
		USB_ConfigurationNumber = 0;
    3a46:	10 92 7f 01 	sts	0x017F, r1	; 0x80017f <USB_ConfigurationNumber>

00003a4a <.Loc.81>:

		USB_INT_Clear(USB_INT_SUSPEND);
    3a4a:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    3a4e:	8e 7f       	andi	r24, 0xFE	; 254
    3a50:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003a54 <.Loc.83>:
		USB_INT_Disable(USB_INT_SUSPEND);
    3a54:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    3a58:	8e 7f       	andi	r24, 0xFE	; 254
    3a5a:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

00003a5e <.Loc.86>:
		USB_INT_Enable(USB_INT_WAKEUP);
    3a5e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>
    3a62:	80 61       	ori	r24, 0x10	; 16
    3a64:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

00003a68 <.Loc.89>:

		Endpoint_ClearEndpoints();
    3a68:	a9 de       	rcall	.-686    	; 0x37bc <Endpoint_ClearEndpoints>

00003a6a <.LBB40>:
			                                                    const uint8_t Type,
			                                                    const uint8_t Direction,
			                                                    const uint16_t Size,
			                                                    const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
    3a6a:	42 e2       	ldi	r20, 0x22	; 34
    3a6c:	60 e0       	ldi	r22, 0x00	; 0
    3a6e:	80 e0       	ldi	r24, 0x00	; 0
    3a70:	94 de       	rcall	.-728    	; 0x379a <Endpoint_ConfigureEndpoint_Prv>

00003a72 <.LBE42>:

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    3a72:	be d0       	rcall	.+380    	; 0x3bf0 <USB_Event_Stub>

00003a74 <.L8>:
	}
	
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    3a74:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003a78 <.Loc.107>:
    3a78:	82 ff       	sbrs	r24, 2
    3a7a:	0a c0       	rjmp	.+20     	; 0x3a90 <.L3>

00003a7c <.Loc.108>:
    3a7c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__DATA_REGION_ORIGIN__+0x82>

00003a80 <.Loc.109>:
    3a80:	82 ff       	sbrs	r24, 2
    3a82:	06 c0       	rjmp	.+12     	; 0x3a90 <.L3>

00003a84 <.Loc.110>:
	{
		USB_INT_Clear(USB_INT_SOFI);
    3a84:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>
    3a88:	8b 7f       	andi	r24, 0xFB	; 251
    3a8a:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__DATA_REGION_ORIGIN__+0x81>

00003a8e <.Loc.112>:
		
		EVENT_USB_Device_StartOfFrame();
    3a8e:	b0 d0       	rcall	.+352    	; 0x3bf0 <USB_Event_Stub>

00003a90 <.L3>:
		EVENT_USB_UIDChange();

		USB_ResetInterface();
	}
	#endif
}
    3a90:	ff 91       	pop	r31
    3a92:	ef 91       	pop	r30
    3a94:	bf 91       	pop	r27
    3a96:	af 91       	pop	r26
    3a98:	9f 91       	pop	r25
    3a9a:	8f 91       	pop	r24
    3a9c:	7f 91       	pop	r23
    3a9e:	6f 91       	pop	r22
    3aa0:	5f 91       	pop	r21
    3aa2:	4f 91       	pop	r20
    3aa4:	3f 91       	pop	r19
    3aa6:	2f 91       	pop	r18
    3aa8:	0f 90       	pop	r0
    3aaa:	0f be       	out	0x3f, r0	; 63
    3aac:	0f 90       	pop	r0
    3aae:	1f 90       	pop	r1
    3ab0:	18 95       	reti

00003ab2 <.L10>:
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    3ab2:	84 e0       	ldi	r24, 0x04	; 4
    3ab4:	b7 cf       	rjmp	.-146    	; 0x3a24 <.L7>

00003ab6 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    3ab6:	1f 93       	push	r17

00003ab8 <.LCFI0>:
    3ab8:	cf 93       	push	r28

00003aba <.LCFI1>:
    3aba:	df 93       	push	r29

00003abc <.LCFI2>:
    3abc:	00 d0       	rcall	.+0      	; 0x3abe <L0^A>

00003abe <L0^A>:
    3abe:	cd b7       	in	r28, 0x3d	; 61
    3ac0:	de b7       	in	r29, 0x3e	; 62

00003ac2 <.LBB64>:
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
    3ac2:	81 e8       	ldi	r24, 0x81	; 129
    3ac4:	91 e0       	ldi	r25, 0x01	; 1

00003ac6 <.L2>:
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
    3ac6:	fc 01       	movw	r30, r24

00003ac8 <.Loc.8>:
    3ac8:	01 96       	adiw	r24, 0x01	; 1

00003aca <.LBB65>:
				return UEDATX;
    3aca:	20 91 f1 00 	lds	r18, 0x00F1	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003ace <.LBE65>:
    3ace:	20 83       	st	Z, r18

00003ad0 <.Loc.13>:
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    3ad0:	21 e0       	ldi	r18, 0x01	; 1
    3ad2:	89 38       	cpi	r24, 0x89	; 137
    3ad4:	92 07       	cpc	r25, r18
    3ad6:	b9 f7       	brne	.-18     	; 0x3ac6 <.L2>

00003ad8 <.LBE67>:
	  
	uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    3ad8:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <USB_ControlRequest>

00003adc <.LVL4>:
	
	switch (USB_ControlRequest.bRequest)
    3adc:	e0 91 82 01 	lds	r30, 0x0182	; 0x800182 <USB_ControlRequest+0x1>

00003ae0 <.LVL5>:
    3ae0:	ea 30       	cpi	r30, 0x0A	; 10
    3ae2:	e8 f4       	brcc	.+58     	; 0x3b1e <.L3>
    3ae4:	f0 e0       	ldi	r31, 0x00	; 0
    3ae6:	e1 5e       	subi	r30, 0xE1	; 225
    3ae8:	f1 4e       	sbci	r31, 0xE1	; 225
    3aea:	8b c0       	rjmp	.+278    	; 0x3c02 <__tablejump2__>

00003aec <.L10>:
	{
		case REQ_GetStatus:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    3aec:	8d 7f       	andi	r24, 0xFD	; 253

00003aee <.LVL6>:
    3aee:	80 38       	cpi	r24, 0x80	; 128
    3af0:	b1 f4       	brne	.+44     	; 0x3b1e <.L3>

00003af2 <.L11>:
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    3af2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003af6 <.LBE68>:
	}

	if (!(RequestHandled))
	  EVENT_USB_Device_UnhandledControlRequest();
	  
	if (Endpoint_IsSETUPReceived())
    3af6:	83 ff       	sbrs	r24, 3
    3af8:	0a c0       	rjmp	.+20     	; 0x3b0e <.L1>

00003afa <.LBB70>:
				UECONX |= (1 << STALLRQ);
    3afa:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>
    3afe:	80 62       	ori	r24, 0x20	; 32
    3b00:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__DATA_REGION_ORIGIN__+0x8b>

00003b04 <.LBB72>:
				UEINTX &= ~(1 << RXSTPI);
    3b04:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3b08:	87 7f       	andi	r24, 0xF7	; 247
    3b0a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003b0e <.L1>:
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();		
	}
}
    3b0e:	0f 90       	pop	r0
    3b10:	0f 90       	pop	r0
    3b12:	df 91       	pop	r29
    3b14:	cf 91       	pop	r28
    3b16:	1f 91       	pop	r17
    3b18:	08 95       	ret

00003b1a <.L9>:
			if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    3b1a:	8d 7f       	andi	r24, 0xFD	; 253

00003b1c <.LVL9>:
    3b1c:	51 f3       	breq	.-44     	; 0x3af2 <.L11>

00003b1e <.L3>:
	  EVENT_USB_Device_UnhandledControlRequest();
    3b1e:	03 dc       	rcall	.-2042   	; 0x3326 <EVENT_USB_Device_UnhandledControlRequest>

00003b20 <.LVL11>:
    3b20:	e8 cf       	rjmp	.-48     	; 0x3af2 <.L11>

00003b22 <.L8>:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    3b22:	81 11       	cpse	r24, r1
    3b24:	fc cf       	rjmp	.-8      	; 0x3b1e <.L3>

00003b26 <.LBB74>:

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    3b26:	10 91 83 01 	lds	r17, 0x0183	; 0x800183 <USB_ControlRequest+0x2>

00003b2a <.LBB76>:
    3b2a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003b2e <.LVL14>:
    3b2e:	87 7f       	andi	r24, 0xF7	; 247
    3b30:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003b34 <.LBE76>:

	Endpoint_ClearSETUP();
	
	Endpoint_ClearStatusStage();
    3b34:	51 de       	rcall	.-862    	; 0x37d8 <Endpoint_ClearStatusStage>

00003b36 <.L13>:
				return ((UEINTX & (1 << TXINI))  ? true : false);
    3b36:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003b3a <.LBE78>:
	
	while (!(Endpoint_IsINReady()))
    3b3a:	80 ff       	sbrs	r24, 0
    3b3c:	0a c0       	rjmp	.+20     	; 0x3b52 <.L14>

00003b3e <.Loc.61>:
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    3b3e:	81 2f       	mov	r24, r17
    3b40:	8f 77       	andi	r24, 0x7F	; 127

00003b42 <.Loc.62>:
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return;
	}

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    3b42:	92 e0       	ldi	r25, 0x02	; 2
    3b44:	09 f0       	breq	.+2      	; 0x3b48 <.L15>
    3b46:	93 e0       	ldi	r25, 0x03	; 3

00003b48 <.L15>:
    3b48:	9e bb       	out	0x1e, r25	; 30

00003b4a <.LBB80>:
			#endif
			
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = ((1 << ADDEN) | (Address & 0x7F));
    3b4a:	80 68       	ori	r24, 0x80	; 128

00003b4c <.Loc.68>:
    3b4c:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__DATA_REGION_ORIGIN__+0x83>

00003b50 <.Loc.69>:
			}			
    3b50:	d0 cf       	rjmp	.-96     	; 0x3af2 <.L11>

00003b52 <.L14>:
		if (USB_DeviceState == DEVICE_STATE_Unattached)
    3b52:	8e b3       	in	r24, 0x1e	; 30

00003b54 <.Loc.73>:
    3b54:	81 11       	cpse	r24, r1
    3b56:	ef cf       	rjmp	.-34     	; 0x3b36 <.L13>
    3b58:	cc cf       	rjmp	.-104    	; 0x3af2 <.L11>

00003b5a <.L7>:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    3b5a:	80 58       	subi	r24, 0x80	; 128

00003b5c <.LVL20>:
    3b5c:	82 30       	cpi	r24, 0x02	; 2
    3b5e:	f8 f6       	brcc	.-66     	; 0x3b1e <.L3>

00003b60 <.LBB82>:
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif
	
	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    3b60:	ae 01       	movw	r20, r28
    3b62:	4f 5f       	subi	r20, 0xFF	; 255
    3b64:	5f 4f       	sbci	r21, 0xFF	; 255
    3b66:	60 91 85 01 	lds	r22, 0x0185	; 0x800185 <USB_ControlRequest+0x4>
    3b6a:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <USB_ControlRequest+0x2>
    3b6e:	90 91 84 01 	lds	r25, 0x0184	; 0x800184 <USB_ControlRequest+0x3>
    3b72:	e8 dd       	rcall	.-1072   	; 0x3744 <CALLBACK_USB_GetDescriptor>

00003b74 <.LVL21>:
    3b74:	bc 01       	movw	r22, r24

00003b76 <.LVL22>:
    3b76:	89 2b       	or	r24, r25
    3b78:	09 f4       	brne	.+2      	; 0x3b7c <.LBB84>

00003b7a <L0^A>:
    3b7a:	bb cf       	rjmp	.-138    	; 0x3af2 <.L11>

00003b7c <.LBB84>:
				UEINTX &= ~(1 << RXSTPI);
    3b7c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3b80:	87 7f       	andi	r24, 0xF7	; 247
    3b82:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003b86 <.LBE84>:
	}
	
	Endpoint_ClearSETUP();

	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
    3b86:	89 81       	ldd	r24, Y+1	; 0x01
    3b88:	9a 81       	ldd	r25, Y+2	; 0x02
    3b8a:	43 de       	rcall	.-890    	; 0x3812 <Endpoint_Write_Control_Stream_LE>

00003b8c <.LBB86>:
					UEINTX &= ~(1 << RXOUTI);	
    3b8c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3b90:	8b 7f       	andi	r24, 0xFB	; 251
    3b92:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003b96 <.LBE86>:
    3b96:	ad cf       	rjmp	.-166    	; 0x3af2 <.L11>

00003b98 <.L6>:
			if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    3b98:	80 38       	cpi	r24, 0x80	; 128
    3b9a:	09 f0       	breq	.+2      	; 0x3b9e <.LBB88>

00003b9c <L0^A>:
    3b9c:	c0 cf       	rjmp	.-128    	; 0x3b1e <.L3>

00003b9e <.LBB88>:
				UEINTX &= ~(1 << RXSTPI);
    3b9e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003ba2 <.LVL25>:
    3ba2:	87 7f       	andi	r24, 0xF7	; 247
    3ba4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003ba8 <.LBE90>:
	Endpoint_Write_Byte(USB_ConfigurationNumber);
    3ba8:	80 91 7f 01 	lds	r24, 0x017F	; 0x80017f <USB_ConfigurationNumber>

00003bac <.LBB92>:
				UEDATX = Byte;
    3bac:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__DATA_REGION_ORIGIN__+0x91>

00003bb0 <.LBB94>:
					UEINTX &= ~(1 << TXINI);
    3bb0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>
    3bb4:	8e 7f       	andi	r24, 0xFE	; 254
    3bb6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003bba <.LBE94>:
	Endpoint_ClearStatusStage();
    3bba:	0e de       	rcall	.-996    	; 0x37d8 <Endpoint_ClearStatusStage>

00003bbc <.LVL29>:
}
    3bbc:	9a cf       	rjmp	.-204    	; 0x3af2 <.L11>

00003bbe <.L4>:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    3bbe:	81 11       	cpse	r24, r1
    3bc0:	ae cf       	rjmp	.-164    	; 0x3b1e <.L3>

00003bc2 <.LBB96>:
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    3bc2:	90 91 83 01 	lds	r25, 0x0183	; 0x800183 <USB_ControlRequest+0x2>
    3bc6:	92 30       	cpi	r25, 0x02	; 2
    3bc8:	08 f0       	brcs	.+2      	; 0x3bcc <.LBB98>

00003bca <L0^A>:
    3bca:	93 cf       	rjmp	.-218    	; 0x3af2 <.L11>

00003bcc <.LBB98>:
				UEINTX &= ~(1 << RXSTPI);
    3bcc:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003bd0 <.LVL31>:
    3bd0:	87 7f       	andi	r24, 0xF7	; 247
    3bd2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003bd6 <.LBE98>:
	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    3bd6:	90 93 7f 01 	sts	0x017F, r25	; 0x80017f <USB_ConfigurationNumber>

00003bda <.Loc.132>:
	Endpoint_ClearStatusStage();
    3bda:	fe dd       	rcall	.-1028   	; 0x37d8 <Endpoint_ClearStatusStage>

00003bdc <.LVL33>:
	USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
    3bdc:	80 91 7f 01 	lds	r24, 0x017F	; 0x80017f <USB_ConfigurationNumber>
    3be0:	81 11       	cpse	r24, r1
    3be2:	04 c0       	rjmp	.+8      	; 0x3bec <.L20>
    3be4:	83 e0       	ldi	r24, 0x03	; 3

00003be6 <.L17>:
    3be6:	8e bb       	out	0x1e, r24	; 30

00003be8 <.Loc.135>:
	EVENT_USB_Device_ConfigurationChanged();
    3be8:	03 d0       	rcall	.+6      	; 0x3bf0 <USB_Event_Stub>

00003bea <.LVL34>:
    3bea:	83 cf       	rjmp	.-250    	; 0x3af2 <.L11>

00003bec <.L20>:
	USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
    3bec:	84 e0       	ldi	r24, 0x04	; 4
    3bee:	fb cf       	rjmp	.-10     	; 0x3be6 <.L17>

00003bf0 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    3bf0:	08 95       	ret

00003bf2 <USB_USBTask>:
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    3bf2:	8e b3       	in	r24, 0x1e	; 30

00003bf4 <.Loc.5>:
    3bf4:	88 23       	and	r24, r24
    3bf6:	21 f0       	breq	.+8      	; 0x3c00 <.L1>

00003bf8 <.LBB18>:
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    3bf8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__DATA_REGION_ORIGIN__+0x88>

00003bfc <.LBE19>:
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
	
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    3bfc:	83 fd       	sbrc	r24, 3

00003bfe <.Loc.16>:
		  USB_Device_ProcessControlRequest();
    3bfe:	5b cf       	rjmp	.-330    	; 0x3ab6 <USB_Device_ProcessControlRequest>

00003c00 <.L1>:
}
    3c00:	08 95       	ret

00003c02 <__tablejump2__>:
    3c02:	ee 0f       	add	r30, r30

00003c04 <.Loc.1>:
    3c04:	ff 1f       	adc	r31, r31

00003c06 <.Loc.2>:
    3c06:	05 90       	lpm	r0, Z+

00003c08 <.Loc.3>:
    3c08:	f4 91       	lpm	r31, Z

00003c0a <.Loc.4>:
    3c0a:	e0 2d       	mov	r30, r0

00003c0c <.Loc.5>:
    3c0c:	09 94       	ijmp

00003c0e <eeprom_read_byte>:
    3c0e:	f9 99       	sbic	0x1f, 1	; 31
    3c10:	fe cf       	rjmp	.-4      	; 0x3c0e <eeprom_read_byte>
    3c12:	92 bd       	out	0x22, r25	; 34
    3c14:	81 bd       	out	0x21, r24	; 33
    3c16:	f8 9a       	sbi	0x1f, 0	; 31
    3c18:	99 27       	eor	r25, r25
    3c1a:	80 b5       	in	r24, 0x20	; 32
    3c1c:	08 95       	ret

00003c1e <eeprom_write_byte>:
    3c1e:	26 2f       	mov	r18, r22

00003c20 <eeprom_write_r18>:
    3c20:	f9 99       	sbic	0x1f, 1	; 31
    3c22:	fe cf       	rjmp	.-4      	; 0x3c20 <eeprom_write_r18>
    3c24:	1f ba       	out	0x1f, r1	; 31
    3c26:	92 bd       	out	0x22, r25	; 34
    3c28:	81 bd       	out	0x21, r24	; 33
    3c2a:	20 bd       	out	0x20, r18	; 32
    3c2c:	0f b6       	in	r0, 0x3f	; 63
    3c2e:	f8 94       	cli
    3c30:	fa 9a       	sbi	0x1f, 2	; 31
    3c32:	f9 9a       	sbi	0x1f, 1	; 31
    3c34:	0f be       	out	0x3f, r0	; 63
    3c36:	01 96       	adiw	r24, 0x01	; 1
    3c38:	08 95       	ret

00003c3a <_exit>:
    3c3a:	f8 94       	cli

00003c3c <__stop_program>:
    3c3c:	ff cf       	rjmp	.-2      	; 0x3c3c <__stop_program>

00003c3e <L0^A>:
    3c3e:	76 1d       	adc	r23, r6
    3c40:	8d 1d       	adc	r24, r13
    3c42:	8f 1d       	adc	r24, r15
    3c44:	8d 1d       	adc	r24, r13
    3c46:	8f 1d       	adc	r24, r15
    3c48:	91 1d       	adc	r25, r1
    3c4a:	ad 1d       	adc	r26, r13
    3c4c:	8f 1d       	adc	r24, r15
    3c4e:	cc 1d       	adc	r28, r12
    3c50:	df 1d       	adc	r29, r15
